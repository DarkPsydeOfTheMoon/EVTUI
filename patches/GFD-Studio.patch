diff --git a/GFDLibrary.Rendering.OpenGL/ConversionHelper.cs b/GFDLibrary.Rendering.OpenGL/ConversionHelper.cs
index bbb6e2f..883e98e 100644
--- a/GFDLibrary.Rendering.OpenGL/ConversionHelper.cs
+++ b/GFDLibrary.Rendering.OpenGL/ConversionHelper.cs
@@ -1,4 +1,4 @@
-﻿using OpenTK;
+﻿using OpenTK.Mathematics;
 
 namespace GFDLibrary.Rendering.OpenGL
 {
diff --git a/GFDLibrary.Rendering.OpenGL/GFDLibrary.Rendering.OpenGL.csproj b/GFDLibrary.Rendering.OpenGL/GFDLibrary.Rendering.OpenGL.csproj
index a620924..d156ace 100644
--- a/GFDLibrary.Rendering.OpenGL/GFDLibrary.Rendering.OpenGL.csproj
+++ b/GFDLibrary.Rendering.OpenGL/GFDLibrary.Rendering.OpenGL.csproj
@@ -14,7 +14,7 @@
   </PropertyGroup>
 
   <ItemGroup>
-    <PackageReference Include="OpenTK" Version="3.1.0" />
+    <PackageReference Include="OpenTK" Version="4.1.0" />
   </ItemGroup>
 
   <ItemGroup>
diff --git a/GFDLibrary.Rendering.OpenGL/GLCamera.cs b/GFDLibrary.Rendering.OpenGL/GLCamera.cs
index d02daac..728e647 100644
--- a/GFDLibrary.Rendering.OpenGL/GLCamera.cs
+++ b/GFDLibrary.Rendering.OpenGL/GLCamera.cs
@@ -1,4 +1,4 @@
-﻿using OpenTK;
+﻿using OpenTK.Mathematics;
 
 namespace GFDLibrary.Rendering.OpenGL
 {
diff --git a/GFDLibrary.Rendering.OpenGL/GLMaterial.cs b/GFDLibrary.Rendering.OpenGL/GLMaterial.cs
index b73d65f..3a621a0 100644
--- a/GFDLibrary.Rendering.OpenGL/GLMaterial.cs
+++ b/GFDLibrary.Rendering.OpenGL/GLMaterial.cs
@@ -4,7 +4,7 @@ using System.Reflection.Metadata;
 using System.Xml.Linq;
 using GFDLibrary.Materials;
 using GFDLibrary.Textures;
-using OpenTK;
+using OpenTK.Mathematics;
 using OpenTK.Graphics.OpenGL;
 using YamlDotNet.Core.Tokens;
 
@@ -297,4 +297,4 @@ namespace GFDLibrary.Rendering.OpenGL
         }
         #endregion
     }
-}
\ No newline at end of file
+}
diff --git a/GFDLibrary.Rendering.OpenGL/GLMesh.cs b/GFDLibrary.Rendering.OpenGL/GLMesh.cs
index 41fcfba..53de6dd 100644
--- a/GFDLibrary.Rendering.OpenGL/GLMesh.cs
+++ b/GFDLibrary.Rendering.OpenGL/GLMesh.cs
@@ -3,7 +3,7 @@ using System.Collections.Generic;
 using System.Diagnostics;
 using System.Numerics;
 using GFDLibrary.Models;
-using OpenTK;
+using OpenTK.Mathematics;
 using OpenTK.Graphics.OpenGL;
 using Vector3 = System.Numerics.Vector3;
 
@@ -146,4 +146,4 @@ namespace GFDLibrary.Rendering.OpenGL
         }
         #endregion
     }
-}
\ No newline at end of file
+}
diff --git a/GFDLibrary.Rendering.OpenGL/GLModel.cs b/GFDLibrary.Rendering.OpenGL/GLModel.cs
index 2ae0f2d..8de9f36 100644
--- a/GFDLibrary.Rendering.OpenGL/GLModel.cs
+++ b/GFDLibrary.Rendering.OpenGL/GLModel.cs
@@ -5,7 +5,7 @@ using System.Linq;
 using System.Numerics;
 using GFDLibrary.Animations;
 using GFDLibrary.Models;
-using OpenTK;
+using OpenTK.Mathematics;
 using OpenTK.Graphics.OpenGL;
 using Quaternion = System.Numerics.Quaternion;
 using Vector3 = System.Numerics.Vector3;
@@ -21,6 +21,7 @@ namespace GFDLibrary.Rendering.OpenGL
         public Dictionary<string, GLMaterial> Materials { get; }
 
         public Animation Animation { get; private set; }
+        public Dictionary<int, Animation> BlendAnimations { get; }
 
         public GLModel( ModelPack modelPack, MaterialTextureCreator textureCreator )
         {
@@ -47,6 +48,8 @@ namespace GFDLibrary.Rendering.OpenGL
                     glNode.Meshes.Add( glMesh );
                 }
             }
+
+            BlendAnimations = new Dictionary<int, Animation>();
         }
 
         public void LoadAnimation( Animation animation )
@@ -93,6 +96,47 @@ namespace GFDLibrary.Rendering.OpenGL
             }
         }
 
+        public void LoadBlendAnimation( Animation animation, int index=-1 )
+        {
+            if (index < 0) { index = BlendAnimations.Count(); }
+            BlendAnimations[index] = animation;
+
+            foreach ( var glNode in Nodes )
+            {
+                int nodeControllerIndex = glNode.BlendControllerIndices.IndexOf( index );
+                List<AnimationController>? controller = null;
+                if (nodeControllerIndex == -1)
+                {
+                    glNode.BlendControllers.Add( new List<AnimationController>());
+                    controller = glNode.BlendControllers.Last();
+                }
+                else
+                {
+                    controller = glNode.BlendControllers[nodeControllerIndex];
+                    controller.Clear();
+                }
+
+                glNode.BlendControllerIndices.Add(index);
+                controller.AddRange( animation.Controllers.Where( x => x.TargetKind == TargetKind.Node &&
+                                                                  x.TargetName == glNode.Node.Name ) );
+            }
+        }
+
+        public void UnloadBlendAnimation( int index )
+        {
+            BlendAnimations.Remove( index );
+
+            foreach (var glNode in Nodes)
+            {
+                int nodeControllerIndex = glNode.BlendControllerIndices.IndexOf( index );
+                if ( nodeControllerIndex != -1 )
+                {
+                    glNode.BlendControllerIndices.RemoveAt( nodeControllerIndex );
+                    glNode.BlendControllers.RemoveAt( nodeControllerIndex );
+                }
+            }
+        }
+
         public void Draw( GLShaderProgram shaderProgram, GLCamera camera, double animationTime )
         {
             var view = camera.View;
@@ -102,7 +146,7 @@ namespace GFDLibrary.Rendering.OpenGL
 
         public void Draw( GLShaderProgram shaderProgram, ref Matrix4 view, ref Matrix4 projection, double animationTime, GLCamera camera )
         {
-            if ( Animation != null )
+            if ( (Animation != null) || (BlendAnimations.Count() != 0) )
                 AnimateNodes( animationTime );
 
             shaderProgram.Use();
@@ -149,7 +193,7 @@ namespace GFDLibrary.Rendering.OpenGL
             GL.Enable( EnableCap.Blend );
 
             // Sort transparent objects based on their distance from the camera
-            transparentMeshes.Sort( ( a, b ) => OpenTK.Vector3.Distance( camera.Translation, b.Item2.ExtractTranslation() ).CompareTo( OpenTK.Vector3.Distance( camera.Translation, a.Item2.ExtractTranslation() ) ) );
+            transparentMeshes.Sort( ( a, b ) => OpenTK.Mathematics.Vector3.Distance( camera.Translation, b.Item2.ExtractTranslation() ).CompareTo( OpenTK.Mathematics.Vector3.Distance( camera.Translation, a.Item2.ExtractTranslation() ) ) );
 
             // Disable depth mask
             GL.DepthMask( false );
@@ -185,56 +229,75 @@ namespace GFDLibrary.Rendering.OpenGL
         }
 
 
-        private void AnimateNodes( double animationTime )
+        private void FetchNodeAnimation( List<AnimationController> controllers, double animationTime, ref Quaternion rotation, ref Vector3 translation, ref Vector3 scale)
         {
-            foreach ( var glNode in Nodes )
+            foreach ( var controller in controllers )
             {
-                var rotation    = glNode.Node.Rotation;
-                var translation = glNode.Node.Translation;
-                var scale       = glNode.Node.Scale;
-
-                foreach ( var controller in glNode.Controllers )
+                foreach ( var layer in controller.Layers )
                 {
-                    foreach ( var layer in controller.Layers )
+                    Key curKey = null;
+                    Key nextKey = null;
+
+                    if ( controller != null )
                     {
-                        Key curKey = null;
-                        Key nextKey = null;
+                        (curKey, nextKey) = GetCurrentAndNextKeys( layer, animationTime );
+                    }
 
-                        if ( controller != null )
+                    if ( controller != null && curKey != null )
+                    {
+                        if ( layer.HasPRSKeyFrames )
                         {
-                            (curKey, nextKey) = GetCurrentAndNextKeys( layer, animationTime );
-                        }
+                            var prsKey = ( PRSKey )curKey;
+                            var nextPrsKey = ( PRSKey )nextKey;
 
-                        if ( controller != null && curKey != null )
-                        {
-                            if ( layer.HasPRSKeyFrames )
+                            if ( nextPrsKey != null )
                             {
-                                var prsKey = ( PRSKey )curKey;
-                                var nextPrsKey = ( PRSKey )nextKey;
-
-                                if ( nextPrsKey != null )
-                                {
-                                    InterpolateKeys( animationTime, layer, ref rotation, ref translation, ref scale, prsKey, nextPrsKey );
-                                }
-                                else
-                                {
-                                    if ( prsKey.HasRotation )
-                                        rotation = prsKey.Rotation;
-
-                                    if ( prsKey.HasPosition )
-                                        translation = prsKey.Position * layer.PositionScale;
-
-                                    if ( prsKey.HasScale )
-                                        scale = prsKey.Scale * layer.ScaleScale;
-                                }
+                                InterpolateKeys( animationTime, layer, ref rotation, ref translation, ref scale, prsKey, nextPrsKey );
                             }
                             else
                             {
-                                //Debugger.Break();
+                                if ( prsKey.HasRotation )
+                                    rotation = prsKey.Rotation;
+
+                                if ( prsKey.HasPosition )
+                                    translation = prsKey.Position * layer.PositionScale;
+
+                                if ( prsKey.HasScale )
+                                    scale = prsKey.Scale * layer.ScaleScale;
                             }
                         }
+                        else
+                        {
+                            //Debugger.Break();
+                        }
                     }
                 }
+            }
+        }
+
+        private void AnimateNodes( double animationTime )
+        {
+            foreach ( var glNode in Nodes )
+            {
+                var rotation    = glNode.Node.Rotation;
+                var translation = glNode.Node.Translation;
+                var scale       = glNode.Node.Scale;
+                FetchNodeAnimation(glNode.Controllers, animationTime, ref rotation, ref translation, ref scale);
+                var rotationEuler = (new OpenTK.Mathematics.Quaternion(rotation.X, rotation.Y, rotation.Z, rotation.W)).ToEulerAngles();
+                
+                foreach ( var blendControllers in glNode.BlendControllers )
+                {
+                    Quaternion blendRotation    = Quaternion.CreateFromYawPitchRoll( 0, 0, 0 );
+                    Vector3    blendTranslation = new Vector3( 0, 0, 0 );
+                    Vector3    blendScale       = new Vector3( 0, 0, 0 );
+                    FetchNodeAnimation(blendControllers, animationTime, ref blendRotation, ref blendTranslation, ref blendScale);
+                    var blendRotationEuler = (new OpenTK.Mathematics.Quaternion(blendRotation.X, blendRotation.Y, blendRotation.Z, blendRotation.W)).ToEulerAngles();
+                    rotationEuler += blendRotationEuler;
+                    translation   += blendTranslation;
+                    scale         += blendScale;
+                }
+                var rotationTK = OpenTK.Mathematics.Quaternion.FromEulerAngles(rotationEuler);
+                rotation = new Quaternion(rotationTK.X, rotationTK.Y, rotationTK.Z, rotationTK.W);
 
                 // Calculate current transform
                 var transform = Matrix4x4.CreateFromQuaternion( rotation ) * Matrix4x4.CreateScale( glNode.Node.Scale );
diff --git a/GFDLibrary.Rendering.OpenGL/GLNode.cs b/GFDLibrary.Rendering.OpenGL/GLNode.cs
index 6ad8f72..d22f91d 100644
--- a/GFDLibrary.Rendering.OpenGL/GLNode.cs
+++ b/GFDLibrary.Rendering.OpenGL/GLNode.cs
@@ -11,6 +11,8 @@ namespace GFDLibrary.Rendering.OpenGL
         public GLNode Parent { get; set; }
         public Node Node { get; set; }
         public List<AnimationController> Controllers { get; }
+        public List<List<AnimationController>> BlendControllers { get; }
+        public List<int> BlendControllerIndices { get;}
         public Matrix4x4 CurrentTransform { get; set; }
         public Matrix4x4 WorldTransform { get; set; }
         public List<GLMesh> Meshes { get; }
@@ -22,6 +24,8 @@ namespace GFDLibrary.Rendering.OpenGL
             WorldTransform = node.WorldTransform;
             Meshes = new List<GLMesh>();
             Controllers = new List<AnimationController>();
+            BlendControllers = new List<List<AnimationController>>();
+            BlendControllerIndices = new List<int>();
         }
 
         #region IDisposable Support
diff --git a/GFDLibrary.Rendering.OpenGL/GLOrthographicCamera.cs b/GFDLibrary.Rendering.OpenGL/GLOrthographicCamera.cs
index 3835e28..bdcd43a 100644
--- a/GFDLibrary.Rendering.OpenGL/GLOrthographicCamera.cs
+++ b/GFDLibrary.Rendering.OpenGL/GLOrthographicCamera.cs
@@ -1,4 +1,4 @@
-﻿using OpenTK;
+﻿using OpenTK.Mathematics;
 
 namespace GFDLibrary.Rendering.OpenGL
 {
diff --git a/GFDLibrary.Rendering.OpenGL/GLPerspectiveCamera.cs b/GFDLibrary.Rendering.OpenGL/GLPerspectiveCamera.cs
index b356c83..b5da266 100644
--- a/GFDLibrary.Rendering.OpenGL/GLPerspectiveCamera.cs
+++ b/GFDLibrary.Rendering.OpenGL/GLPerspectiveCamera.cs
@@ -1,5 +1,5 @@
 ﻿using GFDLibrary.Common;
-using OpenTK;
+using OpenTK.Mathematics;
 
 namespace GFDLibrary.Rendering.OpenGL
 {
diff --git a/GFDLibrary.Rendering.OpenGL/GLShaderProgram.cs b/GFDLibrary.Rendering.OpenGL/GLShaderProgram.cs
index 6e40ff4..a952bf7 100644
--- a/GFDLibrary.Rendering.OpenGL/GLShaderProgram.cs
+++ b/GFDLibrary.Rendering.OpenGL/GLShaderProgram.cs
@@ -2,7 +2,7 @@
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.IO;
-using OpenTK;
+using OpenTK.Mathematics;
 using OpenTK.Graphics.OpenGL;
 
 namespace GFDLibrary.Rendering.OpenGL
diff --git a/GFDLibrary/Animations/Conversion/AnimationConverter.cs b/GFDLibrary/Animations/Conversion/AnimationConverter.cs
index c674133..a7cc999 100644
--- a/GFDLibrary/Animations/Conversion/AnimationConverter.cs
+++ b/GFDLibrary/Animations/Conversion/AnimationConverter.cs
@@ -1,161 +1,161 @@
-﻿using System.Linq;
-using System.Numerics;
-using GFDLibrary.Models.Conversion;
-using Ai = Assimp;
-
-namespace GFDLibrary.Animations.Conversion
-{
-    public static class AnimationConverter
-    {
-        public static Animation ConvertFromAssimpScene( string filePath, AnimationConverterOptions options )
-        {
-            var aiScene = AssimpSceneImporter.ImportFile( filePath );
-            return ConvertFromAssimpScene( aiScene, options );
-        }
-
-        public static Animation ConvertFromAssimpScene( Ai.Scene aiScene, AnimationConverterOptions options )
-        {
-            var aiAnimation = aiScene.Animations.FirstOrDefault();
-            return aiAnimation != null ? ConvertFromAssimpScene( aiScene, aiAnimation, options ) : null;
-        }
-
-        public static Animation ConvertFromAssimpScene( Ai.Scene aiScene, Ai.Animation aiAnimation, AnimationConverterOptions options )
-        {
-            var animation = new Animation( options.Version );
-            animation.Duration = ConvertTime( aiAnimation.DurationInTicks, aiAnimation.TicksPerSecond );
-
-            foreach ( var aiChannel in aiAnimation.NodeAnimationChannels )
-            {
-                if ( AssimpConverterCommon.MeshAttachmentNameRegex.IsMatch( aiChannel.NodeName ) )
-                    continue;
-
-                var nodeName = AssimpConverterCommon.UnescapeName( aiChannel.NodeName );
-
-                Ai.Node node = aiScene.RootNode.FindNode( nodeName );
-                if ( node == null )
-                    continue;
-
-                var controller = new AnimationController( options.Version )
-                {
-                    TargetKind = TargetKind.Node,
-                    TargetName = nodeName,
-                    TargetId = GetTargetIdForNode( aiScene.RootNode, nodeName )
-                };
-
-                var layer = new AnimationLayer( options.Version );
-
-                // NodePRS only for now
-                layer.KeyType = KeyType.NodePRS;
-
-                // Fetch the unique key frame timings from all position, rotation and scale keys.
-                var aiKeyTimings = aiChannel.PositionKeys
-                                               .Select( x => x.Time )
-                                               .Concat( aiChannel.RotationKeys.Select( x => x.Time ) )
-                                               .Concat( aiChannel.ScalingKeys.Select( x => x.Time ) )
-                                               .Distinct()
-                                               .OrderBy( x => x )
-                                               .ToList();
-
-                // Decompose the local transform of the affected node so we can use them as the base values for our keyframes
-
-                node.Transform.Decompose( out var nodeBaseScale, out var nodeBaseRotation, out var nodeBaseTranslation );
-
-                // Keep track of the last position, rotation and scale used to ensure that interpolation works properly
-                var lastPosition = nodeBaseTranslation;
-                var lastRotation = nodeBaseRotation;
-                var lastScale = nodeBaseScale;
-
-                for ( var i = 0; i < aiKeyTimings.Count; i++ )
-                {
-                    var aiTime = aiKeyTimings[ i ];
-
-                    // Start building the keyframe
-                    var key = new PRSKey( layer.KeyType )
-                    {
-                        Position = new Vector3( lastPosition.X, lastPosition.Y, lastPosition.Z ),
-                        Rotation = new Quaternion( lastRotation.X, lastRotation.Y, lastRotation.Z, lastRotation.W ),
-                        Scale    = new Vector3( lastScale.X, lastScale.Y, lastScale.Z )
-                    };
-
-                    // Fetch the Assimp keys for this time
-                    var aiPositionKey = aiChannel.PositionKeys.SingleOrDefault( x => x.Time == aiTime );
-                    var aiRotationKey = aiChannel.RotationKeys.SingleOrDefault( x => x.Time == aiTime );
-                    var aiScaleKey    = aiChannel.ScalingKeys.SingleOrDefault( x => x.Time == aiTime );
-
-                    if ( aiPositionKey != default )
-                    {
-                        key.Position = new Vector3( aiPositionKey.Value.X, aiPositionKey.Value.Y, aiPositionKey.Value.Z );
-                        lastPosition = aiPositionKey.Value;
-                    }
-
-                    if ( aiRotationKey != default )
-                    {
-                        key.Rotation = new Quaternion( aiRotationKey.Value.X, aiRotationKey.Value.Y, aiRotationKey.Value.Z,
-                                                       aiRotationKey.Value.W );
-                        lastRotation = aiRotationKey.Value;
-                    }
-
-                    if ( aiScaleKey != default )
-                    {
-                        key.Scale = new Vector3( aiScaleKey.Value.X, aiScaleKey.Value.Y, aiScaleKey.Value.Z );
-                        lastScale = aiScaleKey.Value;
-                    }
-
-                    key.Time = ConvertTime( aiTime, aiAnimation.TicksPerSecond );
-                    layer.Keys.Add( key );
-                }
-
-                controller.Layers.Add( layer );
-                animation.Controllers.Add( controller );
-            }
-
-            return animation;
-        }
-
-        private static float ConvertTime( double ticks, double ticksPerSecond )
-        {
-            return ( float )( ticks / ( ( ticksPerSecond / 30f ) * 30f ) );
-        }
-
-        private static int GetTargetIdForNode( Ai.Node rootNode, string nodeName )
-        {
-            int targetId = 0;
-
-            bool GetTargetIdForNodeRecursive( Ai.Node node )
-            {
-                if ( node.Name == nodeName )
-                {
-                    return true;
-                }
-
-                ++targetId;
-
-                foreach ( var child in node.Children )
-                {
-                    if ( GetTargetIdForNodeRecursive( child ) )
-                        return true;
-                }
-
-                return false;
-            }
-
-            if ( GetTargetIdForNodeRecursive( rootNode ) )
-                return targetId;
-            else
-                return -1;
-        }
-    }
-
-    public class AnimationConverterOptions
-    {
-        /// <summary>
-        /// Gets or sets the version to use for the converted resources.
-        /// </summary>
-        public uint Version { get; set; }
-
-        public AnimationConverterOptions()
-        {
-            Version = ResourceVersion.Persona5;
-        }
-    }
-}
+﻿// using System.Linq;
+// using System.Numerics;
+// using GFDLibrary.Models.Conversion;
+// using Ai = Assimp;
+
+// namespace GFDLibrary.Animations.Conversion
+// {
+//     public static class AnimationConverter
+//     {
+//         public static Animation ConvertFromAssimpScene( string filePath, AnimationConverterOptions options )
+//         {
+//             var aiScene = AssimpSceneImporter.ImportFile( filePath );
+//             return ConvertFromAssimpScene( aiScene, options );
+//         }
+
+//         public static Animation ConvertFromAssimpScene( Ai.Scene aiScene, AnimationConverterOptions options )
+//         {
+//             var aiAnimation = aiScene.Animations.FirstOrDefault();
+//             return aiAnimation != null ? ConvertFromAssimpScene( aiScene, aiAnimation, options ) : null;
+//         }
+
+//         public static Animation ConvertFromAssimpScene( Ai.Scene aiScene, Ai.Animation aiAnimation, AnimationConverterOptions options )
+//         {
+//             var animation = new Animation( options.Version );
+//             animation.Duration = ConvertTime( aiAnimation.DurationInTicks, aiAnimation.TicksPerSecond );
+
+//             foreach ( var aiChannel in aiAnimation.NodeAnimationChannels )
+//             {
+//                 if ( AssimpConverterCommon.MeshAttachmentNameRegex.IsMatch( aiChannel.NodeName ) )
+//                     continue;
+
+//                 var nodeName = AssimpConverterCommon.UnescapeName( aiChannel.NodeName );
+
+//                 Ai.Node node = aiScene.RootNode.FindNode( nodeName );
+//                 if ( node == null )
+//                     continue;
+
+//                 var controller = new AnimationController( options.Version )
+//                 {
+//                     TargetKind = TargetKind.Node,
+//                     TargetName = nodeName,
+//                     TargetId = GetTargetIdForNode( aiScene.RootNode, nodeName )
+//                 };
+
+//                 var layer = new AnimationLayer( options.Version );
+
+//                 // NodePRS only for now
+//                 layer.KeyType = KeyType.NodePRS;
+
+//                 // Fetch the unique key frame timings from all position, rotation and scale keys.
+//                 var aiKeyTimings = aiChannel.PositionKeys
+//                                                .Select( x => x.Time )
+//                                                .Concat( aiChannel.RotationKeys.Select( x => x.Time ) )
+//                                                .Concat( aiChannel.ScalingKeys.Select( x => x.Time ) )
+//                                                .Distinct()
+//                                                .OrderBy( x => x )
+//                                                .ToList();
+
+//                 // Decompose the local transform of the affected node so we can use them as the base values for our keyframes
+
+//                 node.Transform.Decompose( out var nodeBaseScale, out var nodeBaseRotation, out var nodeBaseTranslation );
+
+//                 // Keep track of the last position, rotation and scale used to ensure that interpolation works properly
+//                 var lastPosition = nodeBaseTranslation;
+//                 var lastRotation = nodeBaseRotation;
+//                 var lastScale = nodeBaseScale;
+
+//                 for ( var i = 0; i < aiKeyTimings.Count; i++ )
+//                 {
+//                     var aiTime = aiKeyTimings[ i ];
+
+//                     // Start building the keyframe
+//                     var key = new PRSKey( layer.KeyType )
+//                     {
+//                         Position = new Vector3( lastPosition.X, lastPosition.Y, lastPosition.Z ),
+//                         Rotation = new Quaternion( lastRotation.X, lastRotation.Y, lastRotation.Z, lastRotation.W ),
+//                         Scale    = new Vector3( lastScale.X, lastScale.Y, lastScale.Z )
+//                     };
+
+//                     // Fetch the Assimp keys for this time
+//                     var aiPositionKey = aiChannel.PositionKeys.SingleOrDefault( x => x.Time == aiTime );
+//                     var aiRotationKey = aiChannel.RotationKeys.SingleOrDefault( x => x.Time == aiTime );
+//                     var aiScaleKey    = aiChannel.ScalingKeys.SingleOrDefault( x => x.Time == aiTime );
+
+//                     if ( aiPositionKey != default )
+//                     {
+//                         key.Position = new Vector3( aiPositionKey.Value.X, aiPositionKey.Value.Y, aiPositionKey.Value.Z );
+//                         lastPosition = aiPositionKey.Value;
+//                     }
+
+//                     if ( aiRotationKey != default )
+//                     {
+//                         key.Rotation = new Quaternion( aiRotationKey.Value.X, aiRotationKey.Value.Y, aiRotationKey.Value.Z,
+//                                                        aiRotationKey.Value.W );
+//                         lastRotation = aiRotationKey.Value;
+//                     }
+
+//                     if ( aiScaleKey != default )
+//                     {
+//                         key.Scale = new Vector3( aiScaleKey.Value.X, aiScaleKey.Value.Y, aiScaleKey.Value.Z );
+//                         lastScale = aiScaleKey.Value;
+//                     }
+
+//                     key.Time = ConvertTime( aiTime, aiAnimation.TicksPerSecond );
+//                     layer.Keys.Add( key );
+//                 }
+
+//                 controller.Layers.Add( layer );
+//                 animation.Controllers.Add( controller );
+//             }
+
+//             return animation;
+//         }
+
+//         private static float ConvertTime( double ticks, double ticksPerSecond )
+//         {
+//             return ( float )( ticks / ( ( ticksPerSecond / 30f ) * 30f ) );
+//         }
+
+//         private static int GetTargetIdForNode( Ai.Node rootNode, string nodeName )
+//         {
+//             int targetId = 0;
+
+//             bool GetTargetIdForNodeRecursive( Ai.Node node )
+//             {
+//                 if ( node.Name == nodeName )
+//                 {
+//                     return true;
+//                 }
+
+//                 ++targetId;
+
+//                 foreach ( var child in node.Children )
+//                 {
+//                     if ( GetTargetIdForNodeRecursive( child ) )
+//                         return true;
+//                 }
+
+//                 return false;
+//             }
+
+//             if ( GetTargetIdForNodeRecursive( rootNode ) )
+//                 return targetId;
+//             else
+//                 return -1;
+//         }
+//     }
+
+//     public class AnimationConverterOptions
+//     {
+//         /// <summary>
+//         /// Gets or sets the version to use for the converted resources.
+//         /// </summary>
+//         public uint Version { get; set; }
+
+//         public AnimationConverterOptions()
+//         {
+//             Version = ResourceVersion.Persona5;
+//         }
+//     }
+// }
diff --git a/GFDLibrary/Api/FlatApi.cs b/GFDLibrary/Api/FlatApi.cs
index 7a6a240..7a1fe4d 100644
--- a/GFDLibrary/Api/FlatApi.cs
+++ b/GFDLibrary/Api/FlatApi.cs
@@ -9,7 +9,7 @@ using System.Linq;
 using System.Numerics;
 using System.Text;
 using System.Threading.Tasks;
-using Scarlet.Platform.Sony;
+//using Scarlet.Platform.Sony;
 using GFDLibrary.Materials;
 using GFDLibrary.Animations;
 
diff --git a/GFDLibrary/GFDLibrary.NET6.csproj b/GFDLibrary/GFDLibrary.NET6.csproj
index 3ec5928..c82c58d 100644
--- a/GFDLibrary/GFDLibrary.NET6.csproj
+++ b/GFDLibrary/GFDLibrary.NET6.csproj
@@ -18,7 +18,7 @@
   </PropertyGroup>
 
   <ItemGroup>
-    <PackageReference Include="AssimpNet" Version="5.0.0-beta1" />
+    <!--PackageReference Include="AssimpNet" Version="5.0.0-beta1" /-->
     <PackageReference Include="BCnEncoder.Net" Version="2.1.0" />
     <PackageReference Include="BCnEncoder.Net.ImageSharp" Version="1.1.1" />
     <PackageReference Include="CSharpImageLibrary" Version="4.2.0" />
@@ -27,9 +27,9 @@
   </ItemGroup>
 
   <ItemGroup>
-    <ProjectReference Include="..\Dependencies\Scarlet\Scarlet.IO.ImageFormats\Scarlet.IO.ImageFormats.csproj" />
-    <ProjectReference Include="..\Dependencies\Scarlet\Scarlet\Scarlet.csproj" />
-    <ProjectReference Include="..\Dependencies\tga-decoder-cs\TgaDecoderTest.csproj" />
+    <!--ProjectReference Include="..\Dependencies\Scarlet\Scarlet.IO.ImageFormats\Scarlet.IO.ImageFormats.csproj" /-->
+    <!--ProjectReference Include="..\Dependencies\Scarlet\Scarlet\Scarlet.csproj" /-->
+    <!--ProjectReference Include="..\Dependencies\tga-decoder-cs\TgaDecoderTest.csproj" /-->
   </ItemGroup>
 
 </Project>
diff --git a/GFDLibrary/Materials/Material.cs b/GFDLibrary/Materials/Material.cs
index 949b619..dc31907 100644
--- a/GFDLibrary/Materials/Material.cs
+++ b/GFDLibrary/Materials/Material.cs
@@ -529,22 +529,22 @@ namespace GFDLibrary.Materials
             }
         }
 
-        public static Material ConvertToMaterialPreset(Material material, ModelPackConverterOptions options)
-        {
-            Material newMaterial = null;
-
-            var materialName = material.Name;
-            var diffuseTexture = material.DiffuseMap;
-            var shadowTexture = material.ShadowMap;
-            if (shadowTexture == null)
-                shadowTexture = material.DiffuseMap;
-            var specularTexture = material.SpecularMap;
-            if (specularTexture == null)
-                specularTexture = material.DiffuseMap;
-            if ( diffuseTexture == null ) newMaterial = material;
-            else newMaterial = MaterialFactory.CreateMaterial( materialName, diffuseTexture.Name, options );
-            return newMaterial;
-        }
+        // public static Material ConvertToMaterialPreset(Material material, ModelPackConverterOptions options)
+        // {
+        //     Material newMaterial = null;
+
+        //     var materialName = material.Name;
+        //     var diffuseTexture = material.DiffuseMap;
+        //     var shadowTexture = material.ShadowMap;
+        //     if (shadowTexture == null)
+        //         shadowTexture = material.DiffuseMap;
+        //     var specularTexture = material.SpecularMap;
+        //     if (specularTexture == null)
+        //         specularTexture = material.DiffuseMap;
+        //     if ( diffuseTexture == null ) newMaterial = material;
+        //     else newMaterial = MaterialFactory.CreateMaterial( materialName, diffuseTexture.Name, options );
+        //     return newMaterial;
+        // }
     }
 
     [Flags]
diff --git a/GFDLibrary/Materials/MaterialDictionary.cs b/GFDLibrary/Materials/MaterialDictionary.cs
index a50d2ed..dda9d78 100644
--- a/GFDLibrary/Materials/MaterialDictionary.cs
+++ b/GFDLibrary/Materials/MaterialDictionary.cs
@@ -3,7 +3,7 @@ using System.Collections;
 using System.Collections.Generic;
 using System.Linq;
 using GFDLibrary.IO;
-using GFDLibrary.Models.Conversion;
+//using GFDLibrary.Models.Conversion;
 
 namespace GFDLibrary.Materials
 {
@@ -30,29 +30,29 @@ namespace GFDLibrary.Materials
             set => mDictionary[name] = value;
         }
 
-        public static MaterialDictionary ConvertAllToMaterialPreset( MaterialDictionary materialDictionary, ModelPackConverterOptions options )
-        {
-            Material newMaterial = null;
-            var newMaterialDictionary = new MaterialDictionary(options.Version);
-
-            foreach (var material in materialDictionary.Materials)
-            {
-                var materialName = material.Name;
-                var diffuseTexture = material.DiffuseMap;
-                var shadowTexture = material.ShadowMap;
-                if (shadowTexture == null)
-                    shadowTexture = material.DiffuseMap;
-                var specularTexture = material.SpecularMap;
-                if (specularTexture == null)
-                    specularTexture = material.DiffuseMap;
-                if (diffuseTexture == null) newMaterial = material;
-
-                else newMaterial = MaterialFactory.CreateMaterial( materialName, diffuseTexture.Name, options );
-                newMaterialDictionary.Add(newMaterial);
-            }
-
-            return newMaterialDictionary;
-        }
+        // public static MaterialDictionary ConvertAllToMaterialPreset( MaterialDictionary materialDictionary, ModelPackConverterOptions options )
+        // {
+        //     Material newMaterial = null;
+        //     var newMaterialDictionary = new MaterialDictionary(options.Version);
+
+        //     foreach (var material in materialDictionary.Materials)
+        //     {
+        //         var materialName = material.Name;
+        //         var diffuseTexture = material.DiffuseMap;
+        //         var shadowTexture = material.ShadowMap;
+        //         if (shadowTexture == null)
+        //             shadowTexture = material.DiffuseMap;
+        //         var specularTexture = material.SpecularMap;
+        //         if (specularTexture == null)
+        //             specularTexture = material.DiffuseMap;
+        //         if (diffuseTexture == null) newMaterial = material;
+
+        //         else newMaterial = MaterialFactory.CreateMaterial( materialName, diffuseTexture.Name, options );
+        //         newMaterialDictionary.Add(newMaterial);
+        //     }
+
+        //     return newMaterialDictionary;
+        // }
 
         public void ReplaceWith(MaterialDictionary other)
         {
diff --git a/GFDLibrary/Materials/MaterialFactory.cs b/GFDLibrary/Materials/MaterialFactory.cs
index 067749b..d324bc3 100644
--- a/GFDLibrary/Materials/MaterialFactory.cs
+++ b/GFDLibrary/Materials/MaterialFactory.cs
@@ -1,70 +1,70 @@
-﻿using System.Collections.Generic;
-using System.Numerics;
-using GFDLibrary.Models;
-using GFDLibrary.Models.Conversion;
+﻿// using System.Collections.Generic;
+// using System.Numerics;
+// using GFDLibrary.Models;
+// using GFDLibrary.Models.Conversion;
 
-namespace GFDLibrary.Materials
-{
-    public static class MaterialFactory
-    {
-        public static Material CreateMaterial( string name, string diffuseMapName, string lightmapName, string displacementMapName, string opacityMapName, string normalMapName, 
-            string heightMapName, string emissiveMapName, string ambientMapName, string specularMapName, string reflectionMapName, ModelPackConverterOptions options )
-        {
-            var MaterialPreset = (Material)options.MaterialPreset;
+// namespace GFDLibrary.Materials
+// {
+//     public static class MaterialFactory
+//     {
+//         public static Material CreateMaterial( string name, string diffuseMapName, string lightmapName, string displacementMapName, string opacityMapName, string normalMapName, 
+//             string heightMapName, string emissiveMapName, string ambientMapName, string specularMapName, string reflectionMapName, ModelPackConverterOptions options )
+//         {
+//             var MaterialPreset = (Material)options.MaterialPreset;
 
-            var material = new Material( name )
-            {
-                AmbientColor = MaterialPreset.AmbientColor,
-                DiffuseColor = MaterialPreset.DiffuseColor,
-                SpecularColor = MaterialPreset.SpecularColor,
-                EmissiveColor = MaterialPreset.EmissiveColor,
-                Field40 = MaterialPreset.Field40,
-                Field44 = MaterialPreset.Field44,
-                DrawMethod = MaterialPreset.DrawMethod,
-                Field49 = MaterialPreset.Field49,
-                Field4A = MaterialPreset.Field4A,
-                Field4B = MaterialPreset.Field4B,
-                Field4C = MaterialPreset.Field4C,
-                Field4D = MaterialPreset.Field4D,
-                DisableBackfaceCulling = MaterialPreset.DisableBackfaceCulling,
-                Field5C = MaterialPreset.Field5C,
-                Field6C = MaterialPreset.Field6C,
-                Field70 = MaterialPreset.Field70,
-                Field90 = MaterialPreset.Field90,
-                Field92 = MaterialPreset.Field92,
-                Field94 = MaterialPreset.Field94,
-                Field96 = MaterialPreset.Field96,
-                Field98 = MaterialPreset.Field98,
-                DiffuseMap = null,
-                GlowMap = null,
-                HighlightMap = null,
-                NightMap = null,
-                NormalMap = null,
-                ReflectionMap = null,
-                ShadowMap = null,
-                SpecularMap = null,
-                Flags = MaterialPreset.Flags,
-                Attributes = MaterialPreset.Attributes
-            };
+//             var material = new Material( name )
+//             {
+//                 AmbientColor = MaterialPreset.AmbientColor,
+//                 DiffuseColor = MaterialPreset.DiffuseColor,
+//                 SpecularColor = MaterialPreset.SpecularColor,
+//                 EmissiveColor = MaterialPreset.EmissiveColor,
+//                 Field40 = MaterialPreset.Field40,
+//                 Field44 = MaterialPreset.Field44,
+//                 DrawMethod = MaterialPreset.DrawMethod,
+//                 Field49 = MaterialPreset.Field49,
+//                 Field4A = MaterialPreset.Field4A,
+//                 Field4B = MaterialPreset.Field4B,
+//                 Field4C = MaterialPreset.Field4C,
+//                 Field4D = MaterialPreset.Field4D,
+//                 DisableBackfaceCulling = MaterialPreset.DisableBackfaceCulling,
+//                 Field5C = MaterialPreset.Field5C,
+//                 Field6C = MaterialPreset.Field6C,
+//                 Field70 = MaterialPreset.Field70,
+//                 Field90 = MaterialPreset.Field90,
+//                 Field92 = MaterialPreset.Field92,
+//                 Field94 = MaterialPreset.Field94,
+//                 Field96 = MaterialPreset.Field96,
+//                 Field98 = MaterialPreset.Field98,
+//                 DiffuseMap = null,
+//                 GlowMap = null,
+//                 HighlightMap = null,
+//                 NightMap = null,
+//                 NormalMap = null,
+//                 ReflectionMap = null,
+//                 ShadowMap = null,
+//                 SpecularMap = null,
+//                 Flags = MaterialPreset.Flags,
+//                 Attributes = MaterialPreset.Attributes
+//             };
 
-            // TODO: which one is which
-            if ( MaterialPreset.DiffuseMap != null ) material.DiffuseMap = new TextureMap( diffuseMapName );
-            // if ( MaterialPreset.GlowMap != null ) material.GlowMap = new TextureMap( diffuseMapName );
-            // if ( MaterialPreset.HighlightMap != null ) material.HighlightMap = new TextureMap( diffuseMapName );
-            // if ( MaterialPreset.NightMap != null ) material.NightMap = new TextureMap( diffuseMapName );
-            if ( MaterialPreset.NormalMap != null ) material.NormalMap = new TextureMap( normalMapName );
-            if ( MaterialPreset.ReflectionMap != null ) material.ReflectionMap = new TextureMap( reflectionMapName );
-            // if ( MaterialPreset.ShadowMap != null ) material.ShadowMap = new TextureMap( diffuseMapName );
-            if ( MaterialPreset.SpecularMap != null ) material.SpecularMap = new TextureMap( specularMapName );
+//             // TODO: which one is which
+//             if ( MaterialPreset.DiffuseMap != null ) material.DiffuseMap = new TextureMap( diffuseMapName );
+//             // if ( MaterialPreset.GlowMap != null ) material.GlowMap = new TextureMap( diffuseMapName );
+//             // if ( MaterialPreset.HighlightMap != null ) material.HighlightMap = new TextureMap( diffuseMapName );
+//             // if ( MaterialPreset.NightMap != null ) material.NightMap = new TextureMap( diffuseMapName );
+//             if ( MaterialPreset.NormalMap != null ) material.NormalMap = new TextureMap( normalMapName );
+//             if ( MaterialPreset.ReflectionMap != null ) material.ReflectionMap = new TextureMap( reflectionMapName );
+//             // if ( MaterialPreset.ShadowMap != null ) material.ShadowMap = new TextureMap( diffuseMapName );
+//             if ( MaterialPreset.SpecularMap != null ) material.SpecularMap = new TextureMap( specularMapName );
 
-            material.IsPresetMaterial = false;
+//             material.IsPresetMaterial = false;
 
-            return material;
-        }
+//             return material;
+//         }
 
-        public static Material CreateMaterial( string name, string diffuseMapName, ModelPackConverterOptions options )
-        {
-            return CreateMaterial(name, diffuseMapName, null, null, null, null, null, null, null, null, null, options);
-        }
-    }
-}
+//         public static Material CreateMaterial( string name, string diffuseMapName, ModelPackConverterOptions options )
+//         {
+//             return CreateMaterial(name, diffuseMapName, null, null, null, null, null, null, null, null, null, options);
+//         }
+//     }
+// }
diff --git a/GFDLibrary/Models/Conversion/AssimpSceneImporter.cs b/GFDLibrary/Models/Conversion/AssimpSceneImporter.cs
index 78265f3..618a735 100644
--- a/GFDLibrary/Models/Conversion/AssimpSceneImporter.cs
+++ b/GFDLibrary/Models/Conversion/AssimpSceneImporter.cs
@@ -1,25 +1,25 @@
-﻿using Ai = Assimp;
+﻿// using Ai = Assimp;
 
-namespace GFDLibrary.Models.Conversion
-{
-    public static class AssimpSceneImporter
-    {
-        public static Ai.Scene ImportFile( string filePath)
-        {
-            // Set up Assimp context
-            var aiContext = new Ai.AssimpContext();
-            aiContext.SetConfig( new Ai.Configs.MeshVertexLimitConfig( 1500 ) ); // estimate
-            aiContext.SetConfig( new Ai.Configs.MeshTriangleLimitConfig( 3000 ) ); // estimate
-            aiContext.SetConfig( new Ai.Configs.VertexCacheSizeConfig( 63 ) ); // PS3/RSX vertex cache size
-            aiContext.SetConfig( new Ai.Configs.FBXPreservePivotsConfig( false ) );
+// namespace GFDLibrary.Models.Conversion
+// {
+//     public static class AssimpSceneImporter
+//     {
+//         public static Ai.Scene ImportFile( string filePath)
+//         {
+//             // Set up Assimp context
+//             var aiContext = new Ai.AssimpContext();
+//             aiContext.SetConfig( new Ai.Configs.MeshVertexLimitConfig( 1500 ) ); // estimate
+//             aiContext.SetConfig( new Ai.Configs.MeshTriangleLimitConfig( 3000 ) ); // estimate
+//             aiContext.SetConfig( new Ai.Configs.VertexCacheSizeConfig( 63 ) ); // PS3/RSX vertex cache size
+//             aiContext.SetConfig( new Ai.Configs.FBXPreservePivotsConfig( false ) );
 
-            // Apply ALL the optimizations
-            var postProcessSteps = Ai.PostProcessSteps.ImproveCacheLocality | Ai.PostProcessSteps.FindInvalidData | Ai.PostProcessSteps.FlipUVs | Ai.PostProcessSteps.JoinIdenticalVertices |
-                                   Ai.PostProcessSteps.LimitBoneWeights | Ai.PostProcessSteps.Triangulate | Ai.PostProcessSteps.GenerateSmoothNormals | Ai.PostProcessSteps.OptimizeMeshes | Ai.PostProcessSteps.CalculateTangentSpace;
+//             // Apply ALL the optimizations
+//             var postProcessSteps = Ai.PostProcessSteps.ImproveCacheLocality | Ai.PostProcessSteps.FindInvalidData | Ai.PostProcessSteps.FlipUVs | Ai.PostProcessSteps.JoinIdenticalVertices |
+//                                    Ai.PostProcessSteps.LimitBoneWeights | Ai.PostProcessSteps.Triangulate | Ai.PostProcessSteps.GenerateSmoothNormals | Ai.PostProcessSteps.OptimizeMeshes | Ai.PostProcessSteps.CalculateTangentSpace;
 
-            var aiScene = aiContext.ImportFile( filePath, postProcessSteps );
+//             var aiScene = aiContext.ImportFile( filePath, postProcessSteps );
 
-            return aiScene;
-        }
-    }
-}
+//             return aiScene;
+//         }
+//     }
+// }
diff --git a/GFDLibrary/Models/Conversion/ModelConverter.cs b/GFDLibrary/Models/Conversion/ModelConverter.cs
index 18e2208..680dc69 100644
--- a/GFDLibrary/Models/Conversion/ModelConverter.cs
+++ b/GFDLibrary/Models/Conversion/ModelConverter.cs
@@ -1,718 +1,718 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Numerics;
-using GFDLibrary.Cameras;
-using GFDLibrary.Common;
-using GFDLibrary.Lights;
-using GFDLibrary.Models.Conversion.Utilities;
-using GFDLibrary.Utilities;
-using Ai = Assimp;
-
-namespace GFDLibrary.Models.Conversion
-{
-    public static class ModelConverter
-    {
-        private static readonly Matrix4x4 YToZUpMatrix = new Matrix4x4( 1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1 );
-
-        private static readonly Matrix4x4 ZToYUpMatrix = new Matrix4x4( 1, 0, 0, 0, 0, 0, -1, 0, 0, 1, 0, 0, 0, 0, 0, 1 );
-
-        public static Model ConvertFromAssimpScene( string filePath, ModelConverterOptions options )
-        {
-            var aiScene = AssimpSceneImporter.ImportFile( filePath );
-            return ConvertFromAssimpScene( aiScene, options );
-        }
-
-        public static Model ConvertFromAssimpScene( Ai.Scene aiScene, ModelConverterOptions options )
-        {
-            var scene = new Model( options.Version );
-
-            // Convert assimp nodes to our nodes 
-            var nodeLookup = new Dictionary<string, NodeInfo>();
-            int nextNodeIndex = 0;
-            scene.RootNode = ConvertAssimpNodeRecursively( aiScene, aiScene.RootNode, nodeLookup, ref nextNodeIndex, options );
-
-            // Process the meshes attached to the assimp nodes
-            var nodeToBoneIndices = new Dictionary<int, List<int>>();
-            int nextBoneIndex = 0;
-            var boneInverseBindMatrices = new List<Matrix4x4>();
-            var transformedVertices = new List< Vector3 >();
-            ProcessAssimpNodeMeshesRecursively( aiScene.RootNode, aiScene, nodeLookup, ref nextBoneIndex, nodeToBoneIndices, boneInverseBindMatrices, transformedVertices, options );
-
-            // Don't build a bone palette if there are no skinned meshes
-            if ( boneInverseBindMatrices.Count > 0 )
-            {
-                // Build bone palette for skinning
-                scene.Bones = BuildBonePalette( boneInverseBindMatrices, nodeToBoneIndices );
-            }
-
-            // Build bounding box & sphere
-            scene.BoundingBox = BoundingBox.Calculate( transformedVertices );
-            scene.BoundingSphere = BoundingSphere.Calculate( scene.BoundingBox.Value, transformedVertices );
-
-            return scene;
-        }
-
-        private static Ai.Matrix4x4 GetWorldTransform( Ai.Node aiNode )
-        {
-            var transform = aiNode.Transform;
-            var parent = aiNode.Parent;
-            while ( parent != null )
-            {
-                transform *= parent.Transform;
-                parent = parent.Parent;
-            }
-
-            return transform;
-        }
-
-        private static bool NearlyEquals( float a, float b, float epsilon = 0.001f )
-        {
-            double absA = Math.Abs( a );
-            double absB = Math.Abs( b );
-            double diff = Math.Abs( a - b );
-
-            if ( a == b )
-            { 
-                // shortcut, handles infinities
-                return true;
-            }
-            else if ( a == 0 || b == 0 || diff < double.Epsilon )
-            {
-                // a or b is zero or both are extremely close to it
-                // relative error is less meaningful here
-                return diff < epsilon;
-            }
-            else
-            { 
-                // use relative error
-                return diff / ( absA + absB ) < epsilon;
-            }
-        }
-
-        private static bool NearlyEquals( Ai.Matrix4x4 left, Ai.Matrix4x4 right )
-        {
-            return NearlyEquals( left.A1, right.A1 ) && NearlyEquals( left.A2, right.A2 ) && NearlyEquals( left.A3, right.A3 ) && NearlyEquals( left.A4, right.A4 ) &&
-                   NearlyEquals( left.B1, right.B1 ) && NearlyEquals( left.B2, right.B2 ) && NearlyEquals( left.B3, right.B3 ) && NearlyEquals( left.B4, right.B4 ) &&
-                   NearlyEquals( left.C1, right.C1 ) && NearlyEquals( left.C2, right.C2 ) && NearlyEquals( left.C3, right.C3 ) && NearlyEquals( left.C4, right.C4 ) &&
-                   NearlyEquals( left.D1, right.D1 ) && NearlyEquals( left.D2, right.D2 ) && NearlyEquals( left.D3, right.D3 ) && NearlyEquals( left.D4, right.D4 );
-        }
-
-        private static bool IsMeshAttachmentNode( Ai.Node node )
-        {
-            bool isMeshAttachmentNode = node.Parent != null &&                                                          // definitely not a mesh attachment if it doesnt have a parent -> RootNode
-                                        node.Parent.Name != "RootNode" &&                                               // probably not a mesh attachment if its part of the scene root
-                                        AssimpConverterCommon.MeshAttachmentNameRegex.IsMatch( node.Name ) &&           // match name regex
-                                        NearlyEquals( node.Transform, Ai.Matrix4x4.Identity );                          // transform must be identity
-
-            return isMeshAttachmentNode;
-        }
-
-        private static void TryAddProperty( UserPropertyDictionary dictionary, UserProperty property )
-        {
-            if ( !dictionary.ContainsKey( property.Name ) )
-                dictionary.Add( property );
-        }
-
-        private static void TryAddFullBodyObjectProperties( UserPropertyDictionary dictionary, string name )
-        {
-            TryAddProperty( dictionary, new UserIntProperty( $"{name}.CatherineData.xrd649_envelope_tone", 100 ) );
-            TryAddProperty( dictionary, new UserIntProperty( $"{name}.CatherineData.xrd649_envelope_edge", 100 ) );
-            TryAddProperty( dictionary, new UserIntProperty( $"{name}.CatherineData.xrd649_envelope", 0 ) );
-            TryAddProperty( dictionary, new UserIntProperty( $"{name}.CatherineData.xrd649_outline", 0 ) );
-            TryAddProperty( dictionary, new UserIntProperty( $"{name}.CatherineData.xrd649_shadow_reciever", 0 ) );
-            TryAddProperty( dictionary, new UserIntProperty( $"{name}.CatherineData.xrd649_shadow_caster", 0 ) );
-            TryAddProperty( dictionary, new UserIntProperty( $"{name}.CatherineData.xrd649_fog_disable", 0 ) );
-            TryAddProperty( dictionary, new UserIntProperty( $"{name}.CatherineData.xrd649_pos_resid", 0 ) );
-            TryAddProperty( dictionary, new UserIntProperty( $"{name}.CatherineData.xrd649_pos_minor", 0 ) );
-            TryAddProperty( dictionary, new UserIntProperty( $"{name}.CatherineData.xrd649_pos_major", 0 ) );
-            TryAddProperty( dictionary, new UserIntProperty( $"{name}.CatherineData.xrd649_pos_type", 1 ) );
-            TryAddProperty( dictionary, new UserIntProperty( $"{name}.CatherineData.xrd649_ca_type", 3 ) );
-        }
-
-        private static HashSet<string> sFullBodyObjectNames = new HashSet<string>()
-        {
-            "bell", "bar", "heart", "clock", "drink01", "drink02", "item_block02", 
-        };
-
-        private static Node ConvertAssimpNodeRecursively( Assimp.Scene aiScene, Ai.Node aiNode, Dictionary<string, NodeInfo> nodeLookup, ref int nextIndex, ModelConverterOptions options )
-        {
-            aiNode.Transform.Decompose( out var scale, out var rotation, out var translation );
-
-            // Create node
-            var node = new Node( AssimpConverterCommon.UnescapeName( aiNode.Name ),
-                                 new Vector3( translation.X, translation.Y, translation.Z ),
-                                 new Quaternion( rotation.X, rotation.Y, rotation.Z, rotation.W ),
-                                 new Vector3( scale.X, scale.Y, scale.Z ) );
+﻿// using System;
+// using System.Collections.Generic;
+// using System.Linq;
+// using System.Numerics;
+// using GFDLibrary.Cameras;
+// using GFDLibrary.Common;
+// using GFDLibrary.Lights;
+// using GFDLibrary.Models.Conversion.Utilities;
+// using GFDLibrary.Utilities;
+// using Ai = Assimp;
+
+// namespace GFDLibrary.Models.Conversion
+// {
+//     public static class ModelConverter
+//     {
+//         private static readonly Matrix4x4 YToZUpMatrix = new Matrix4x4( 1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1 );
+
+//         private static readonly Matrix4x4 ZToYUpMatrix = new Matrix4x4( 1, 0, 0, 0, 0, 0, -1, 0, 0, 1, 0, 0, 0, 0, 0, 1 );
+
+//         public static Model ConvertFromAssimpScene( string filePath, ModelConverterOptions options )
+//         {
+//             var aiScene = AssimpSceneImporter.ImportFile( filePath );
+//             return ConvertFromAssimpScene( aiScene, options );
+//         }
+
+//         public static Model ConvertFromAssimpScene( Ai.Scene aiScene, ModelConverterOptions options )
+//         {
+//             var scene = new Model( options.Version );
+
+//             // Convert assimp nodes to our nodes 
+//             var nodeLookup = new Dictionary<string, NodeInfo>();
+//             int nextNodeIndex = 0;
+//             scene.RootNode = ConvertAssimpNodeRecursively( aiScene, aiScene.RootNode, nodeLookup, ref nextNodeIndex, options );
+
+//             // Process the meshes attached to the assimp nodes
+//             var nodeToBoneIndices = new Dictionary<int, List<int>>();
+//             int nextBoneIndex = 0;
+//             var boneInverseBindMatrices = new List<Matrix4x4>();
+//             var transformedVertices = new List< Vector3 >();
+//             ProcessAssimpNodeMeshesRecursively( aiScene.RootNode, aiScene, nodeLookup, ref nextBoneIndex, nodeToBoneIndices, boneInverseBindMatrices, transformedVertices, options );
+
+//             // Don't build a bone palette if there are no skinned meshes
+//             if ( boneInverseBindMatrices.Count > 0 )
+//             {
+//                 // Build bone palette for skinning
+//                 scene.Bones = BuildBonePalette( boneInverseBindMatrices, nodeToBoneIndices );
+//             }
+
+//             // Build bounding box & sphere
+//             scene.BoundingBox = BoundingBox.Calculate( transformedVertices );
+//             scene.BoundingSphere = BoundingSphere.Calculate( scene.BoundingBox.Value, transformedVertices );
+
+//             return scene;
+//         }
+
+//         private static Ai.Matrix4x4 GetWorldTransform( Ai.Node aiNode )
+//         {
+//             var transform = aiNode.Transform;
+//             var parent = aiNode.Parent;
+//             while ( parent != null )
+//             {
+//                 transform *= parent.Transform;
+//                 parent = parent.Parent;
+//             }
+
+//             return transform;
+//         }
+
+//         private static bool NearlyEquals( float a, float b, float epsilon = 0.001f )
+//         {
+//             double absA = Math.Abs( a );
+//             double absB = Math.Abs( b );
+//             double diff = Math.Abs( a - b );
+
+//             if ( a == b )
+//             { 
+//                 // shortcut, handles infinities
+//                 return true;
+//             }
+//             else if ( a == 0 || b == 0 || diff < double.Epsilon )
+//             {
+//                 // a or b is zero or both are extremely close to it
+//                 // relative error is less meaningful here
+//                 return diff < epsilon;
+//             }
+//             else
+//             { 
+//                 // use relative error
+//                 return diff / ( absA + absB ) < epsilon;
+//             }
+//         }
+
+//         private static bool NearlyEquals( Ai.Matrix4x4 left, Ai.Matrix4x4 right )
+//         {
+//             return NearlyEquals( left.A1, right.A1 ) && NearlyEquals( left.A2, right.A2 ) && NearlyEquals( left.A3, right.A3 ) && NearlyEquals( left.A4, right.A4 ) &&
+//                    NearlyEquals( left.B1, right.B1 ) && NearlyEquals( left.B2, right.B2 ) && NearlyEquals( left.B3, right.B3 ) && NearlyEquals( left.B4, right.B4 ) &&
+//                    NearlyEquals( left.C1, right.C1 ) && NearlyEquals( left.C2, right.C2 ) && NearlyEquals( left.C3, right.C3 ) && NearlyEquals( left.C4, right.C4 ) &&
+//                    NearlyEquals( left.D1, right.D1 ) && NearlyEquals( left.D2, right.D2 ) && NearlyEquals( left.D3, right.D3 ) && NearlyEquals( left.D4, right.D4 );
+//         }
+
+//         private static bool IsMeshAttachmentNode( Ai.Node node )
+//         {
+//             bool isMeshAttachmentNode = node.Parent != null &&                                                          // definitely not a mesh attachment if it doesnt have a parent -> RootNode
+//                                         node.Parent.Name != "RootNode" &&                                               // probably not a mesh attachment if its part of the scene root
+//                                         AssimpConverterCommon.MeshAttachmentNameRegex.IsMatch( node.Name ) &&           // match name regex
+//                                         NearlyEquals( node.Transform, Ai.Matrix4x4.Identity );                          // transform must be identity
+
+//             return isMeshAttachmentNode;
+//         }
+
+//         private static void TryAddProperty( UserPropertyDictionary dictionary, UserProperty property )
+//         {
+//             if ( !dictionary.ContainsKey( property.Name ) )
+//                 dictionary.Add( property );
+//         }
+
+//         private static void TryAddFullBodyObjectProperties( UserPropertyDictionary dictionary, string name )
+//         {
+//             TryAddProperty( dictionary, new UserIntProperty( $"{name}.CatherineData.xrd649_envelope_tone", 100 ) );
+//             TryAddProperty( dictionary, new UserIntProperty( $"{name}.CatherineData.xrd649_envelope_edge", 100 ) );
+//             TryAddProperty( dictionary, new UserIntProperty( $"{name}.CatherineData.xrd649_envelope", 0 ) );
+//             TryAddProperty( dictionary, new UserIntProperty( $"{name}.CatherineData.xrd649_outline", 0 ) );
+//             TryAddProperty( dictionary, new UserIntProperty( $"{name}.CatherineData.xrd649_shadow_reciever", 0 ) );
+//             TryAddProperty( dictionary, new UserIntProperty( $"{name}.CatherineData.xrd649_shadow_caster", 0 ) );
+//             TryAddProperty( dictionary, new UserIntProperty( $"{name}.CatherineData.xrd649_fog_disable", 0 ) );
+//             TryAddProperty( dictionary, new UserIntProperty( $"{name}.CatherineData.xrd649_pos_resid", 0 ) );
+//             TryAddProperty( dictionary, new UserIntProperty( $"{name}.CatherineData.xrd649_pos_minor", 0 ) );
+//             TryAddProperty( dictionary, new UserIntProperty( $"{name}.CatherineData.xrd649_pos_major", 0 ) );
+//             TryAddProperty( dictionary, new UserIntProperty( $"{name}.CatherineData.xrd649_pos_type", 1 ) );
+//             TryAddProperty( dictionary, new UserIntProperty( $"{name}.CatherineData.xrd649_ca_type", 3 ) );
+//         }
+
+//         private static HashSet<string> sFullBodyObjectNames = new HashSet<string>()
+//         {
+//             "bell", "bar", "heart", "clock", "drink01", "drink02", "item_block02", 
+//         };
+
+//         private static Node ConvertAssimpNodeRecursively( Assimp.Scene aiScene, Ai.Node aiNode, Dictionary<string, NodeInfo> nodeLookup, ref int nextIndex, ModelConverterOptions options )
+//         {
+//             aiNode.Transform.Decompose( out var scale, out var rotation, out var translation );
+
+//             // Create node
+//             var node = new Node( AssimpConverterCommon.UnescapeName( aiNode.Name ),
+//                                  new Vector3( translation.X, translation.Y, translation.Z ),
+//                                  new Quaternion( rotation.X, rotation.Y, rotation.Z, rotation.W ),
+//                                  new Vector3( scale.X, scale.Y, scale.Z ) );
 
             
 
-            if ( !IsMeshAttachmentNode( aiNode ) )
-            {
-                // Convert properties
-                ConvertAssimpMetadataToProperties( aiNode.Metadata, node );
-
-                if ( options.SetFullBodyNodeProperties )
-                {
-                    if (node.Name == "See User Defined Properties" )
-                    {
-                        TryAddProperty( node.Properties, new UserIntProperty( "NiSortAdjustNode", 0 ) );
-                    }
-                    else if ( node.Name.EndsWith( "root" ) || node.Name == "Bip01" )
-                    {
-                        TryAddProperty( node.Properties, new UserIntProperty( "KFAccumRoot", 0 ) );
-                    }
-                    else if ( sFullBodyObjectNames.Contains( node.Name ) )
-                    {
-                        TryAddFullBodyObjectProperties( node.Properties, node.Name );
-                    }
-                }
-
-                if ( options.AutoAddGFDHelperIDs ) // for P5/R
-                {
-                    switch( node.Name )
-                    {
-                        case "h_B_BD1":
-                            TryAddProperty( node.Properties, new UserIntProperty( "gfdHelperID", 501 ) );
-                            break;
-
-                        case "h_C_US3":
-                            TryAddProperty( node.Properties, new UserIntProperty( "gfdHelperID", 3 ) );
-                            break;
-
-                        case "h_C_FS1":
-                            TryAddProperty( node.Properties, new UserIntProperty( "gfdHelperID", 21 ) );
-                            break;
-
-                        case "h_M_HR3":
-                            TryAddProperty( node.Properties, new UserIntProperty( "gfdHelperID", 103 ) );
-                            break;
-
-                        case "h_B_KA1":
-                            TryAddProperty( node.Properties, new UserIntProperty( "gfdHelperID", 502 ) );
-                            break;
-
-                        case "h_B_CT1":
-                            TryAddProperty( node.Properties, new UserIntProperty( "gfdHelperID", 521 ) );
-                            break;
-
-                        case "h_C_US2":
-                            TryAddProperty( node.Properties, new UserIntProperty( "gfdHelperID", 2 ) );
-                            break;
-
-                        case "h_C_BS1":
-                            TryAddProperty( node.Properties, new UserIntProperty( "gfdHelperID", 11 ) );
-                            break;
-
-                        case "h_M_HL2":
-                            TryAddProperty( node.Properties, new UserIntProperty( "gfdHelperID", 152 ) );
-                            break;
-
-                        case "h_B_MZ1":
-                            TryAddProperty( node.Properties, new UserIntProperty( "gfdHelperID", 511 ) );
-                            break;
-
-                        case "h_M_HR2":
-                            TryAddProperty( node.Properties, new UserIntProperty( "gfdHelperID", 102 ) );
-                            break;
-
-                        case "h_M_HL1":
-                            TryAddProperty( node.Properties, new UserIntProperty( "gfdHelperID", 151 ) );
-                            break;
-
-                        case "h_M_BC1":
-                            TryAddProperty( node.Properties, new UserIntProperty( "gfdHelperID", 301 ) );
-                            break;
-
-                        case "h_C_US1":
-                            TryAddProperty( node.Properties, new UserIntProperty( "gfdHelperID", 1 ) );
-                            break;
-
-                        case "h_M_HL3":
-                            TryAddProperty( node.Properties, new UserIntProperty( "gfdHelperID", 153 ) );
-                            break;
-
-                        case "h_M_HR1":
-                            TryAddProperty( node.Properties, new UserIntProperty( "gfdHelperID", 101 ) );
-                            break;
-
-                        default:
-                            break;
-                    }
-                }
-
-                if ( !nodeLookup.ContainsKey( node.Name ) )
-                {
-                    // Add to lookup
-                    nodeLookup.Add( node.Name, new NodeInfo( aiNode, node, nextIndex++, false ) );
-                }
-                else
-                {
-                    throw new Exception( $"Duplicate node name '{node.Name}'" );
-                }
-
-                // Is this a camera?
-                var index = -1;
-                if ( ( index = aiScene.Cameras.FindIndex( x => x.Name == node.Name ) ) != -1 )
-                {
-                    var aiCamera = aiScene.Cameras[ index ];
-                    var camera = new Camera( -aiCamera.Direction.ToNumerics(), aiCamera.Up.ToNumerics(), aiCamera.Position.ToNumerics(),
-                        aiCamera.ClipPlaneNear, aiCamera.ClipPlaneFar, MathHelper.RadiansToDegrees( aiCamera.FieldOfview ),
-                        aiCamera.AspectRatio, 0 
-                    ) { Version = options.Version };
-
-                    node.Attachments.Add( new NodeCameraAttachment( camera ) );
-                }
-                else if ( ( index = aiScene.Lights.FindIndex( x => x.Name == node.Name ) ) != -1 )
-                {
-                    var aiLight = aiScene.Lights[ index ];
-                    var lightType = LightType.Point;
-                    switch ( aiLight.LightType )
-                    {
-                        case Ai.LightSourceType.Directional:
-                            lightType = LightType.Type1;
-                            break;
-                        case Ai.LightSourceType.Point:
-                        case Ai.LightSourceType.Ambient:
-                            lightType = LightType.Point;
-                            break;
-                        case Ai.LightSourceType.Spot:
-                            lightType = LightType.Spot;
-                            break;
-                    }
-
-                    var light = new Light
-                    {
-                        Version = options.Version,
-                        AmbientColor   = aiLight.ColorAmbient.ToNumerics(),
-                        DiffuseColor   = aiLight.ColorDiffuse.ToNumerics(),
-                        SpecularColor  = aiLight.ColorSpecular.ToNumerics(),
-                        AngleInnerCone = aiLight.AngleInnerCone,
-                        AngleOuterCone = aiLight.AngleOuterCone,
-                        Type           = lightType,
-                        Flags          = LightFlags.Bit1 | LightFlags.Bit2
-                    };
-                    node.Attachments.Add( new NodeLightAttachment( light ) );
-                }
-
-                // Process children
-                foreach ( var aiNodeChild in aiNode.Children )
-                {
-                    if ( aiNodeChild.Name == "RootNode" )
-                    {
-                        // For compatibility with old exports 
-                        // Merge children of 'RootNode' node with actual root node
-                        foreach ( var aiFakeRootNodeChild in aiNodeChild.Children )
-                        {
-                            var childNode = ConvertAssimpNodeRecursively( aiScene, aiFakeRootNodeChild, nodeLookup, ref nextIndex, options );
-                            node.AddChildNode( childNode );
-                        }
-                    }
-                    else
-                    {
-                        var childNode = ConvertAssimpNodeRecursively( aiScene, aiNodeChild, nodeLookup, ref nextIndex, options );
-                        node.AddChildNode( childNode );
-                    }
-                }
-            }
-            else
-            {
-                nodeLookup.Add( node.Name, new NodeInfo( aiNode, node, -1, true ) );
-            }
-
-            return node;
-        }
-
-        private static void ConvertAssimpMetadataToProperties( Ai.Metadata metadata, Node node )
-        {
-            foreach ( var metadataEntry in metadata )
-            {
-                UserProperty property = null;
-
-                // Skip some garbage entries
-                if ( metadataEntry.Key == "IsNull" ||
-                     metadataEntry.Key == "InheritType" ||
-                     metadataEntry.Key == "DefaultAttributeIndex" ||
-                     metadataEntry.Key == "UserProperties" || // dupe of UDP3DSMAX
-                     metadataEntry.Key == "ScalingMax" ||
-                     metadataEntry.Key == "MaxHandle" )
-                {
-                    continue;
-                }
-
-                if ( metadataEntry.Key == "UDP3DSMAX" )
-                {
-                    var properties = ( ( string )metadataEntry.Value.Data )
-                        .Split( new[] { "&cr;&lf;", "\r\n", "\n" }, StringSplitOptions.RemoveEmptyEntries );
-
-                    if ( properties.Length == 0 )
-                        continue;
-
-                    foreach ( var propertyString in properties )
-                    {
-                        // Parse property string
-                        KeyValuePair<string, string> kvp;
-                        if ( propertyString.Contains( '=' ) )
-                        {
-                            var split = propertyString.Split( '=' );
-                            kvp = new KeyValuePair<string, string>( split[0].TrimEnd(), split[1].TrimStart() );
-                        }
-                        else
-                        {
-                            var split = propertyString.Split( ' ' );
-                            kvp = new KeyValuePair<string, string>( split[0], split.Length > 1 ? split[1] : null );
-                        }
-
-                        // Parse value
-                        if ( kvp.Value == null )
-                        {
-                            // Assume flag bool
-                            property = new UserBoolProperty( kvp.Key, true );
-                        }
-                        else if ( kvp.Value.StartsWith( "[" ) && kvp.Value.EndsWith( "]" ) )
-                        {
-                            // Array/Vector
-                            var arrayContents = kvp.Value.Substring( 1, kvp.Value.Length - 2 );
-                            var arrayValues = arrayContents.Split( new[] { ',' }, StringSplitOptions.RemoveEmptyEntries );
-
-                            var arrayFloatValues = new List<float>();
-                            foreach ( var arrayValue in arrayValues )
-                            {
-                                if ( !float.TryParse( arrayValue, out var arrayFloatValue ) )
-                                {
-                                    throw new Exception( $"Failed to parse array user property value as float: {arrayValue}" );
-                                }
-
-                                arrayFloatValues.Add( arrayFloatValue );
-                            }
-
-                            if ( arrayFloatValues.Count == 3 )
-                            {
-                                property = new UserVector3Property( kvp.Key, new Vector3( arrayFloatValues[0], arrayFloatValues[1], arrayFloatValues[2] ) );
-                            }
-                            else if ( arrayFloatValues.Count == 4 )
-                            {
-                                property = new UserVector4Property( kvp.Key, new Vector4( arrayFloatValues[0], arrayFloatValues[1], arrayFloatValues[2], arrayFloatValues[3] ) );
-                            }
-                            else
-                            {
-                                var arrayByteValues = arrayFloatValues.Cast<byte>();
-                                property = new UserByteArrayProperty( kvp.Key, arrayByteValues.ToArray() );
-                            }
-                        }
-                        else if ( int.TryParse( kvp.Value, out int intValue ) )
-                        {
-                            property = new UserIntProperty( kvp.Key, intValue );
-                        }
-                        else if ( float.TryParse( kvp.Value, out float floatValue ) )
-                        {
-                            property = new UserFloatProperty( kvp.Key, floatValue );
-                        }
-                        else if ( bool.TryParse( kvp.Value, out bool boolValue ) )
-                        {
-                            property = new UserBoolProperty( kvp.Key, boolValue );
-                        }
-                        else
-                        {
-                            property = new UserStringProperty( kvp.Key, kvp.Value );
-                        }
-                    }
-                }
-                else
-                {
-                    switch ( metadataEntry.Value.DataType )
-                    {
-                        case Ai.MetaDataType.Bool:
-                            property = new UserBoolProperty( metadataEntry.Key, metadataEntry.Value.DataAs<bool>().Value );
-                            break;
-                        case Ai.MetaDataType.Int32:
-                            property = new UserIntProperty( metadataEntry.Key, metadataEntry.Value.DataAs<int>().Value );
-                            break;
-                        case Ai.MetaDataType.UInt64:
-                            property = new UserByteArrayProperty( metadataEntry.Key, BitConverter.GetBytes( metadataEntry.Value.DataAs<ulong>().Value ) );
-                            break;
-                        case Ai.MetaDataType.Float:
-                            property = new UserFloatProperty( metadataEntry.Key, metadataEntry.Value.DataAs<float>().Value );
-                            break;
-                        case Ai.MetaDataType.String:
-                            property = new UserStringProperty( metadataEntry.Key, ( string )metadataEntry.Value.Data );
-                            break;
-                        case Ai.MetaDataType.Vector3D:
-                            var data = metadataEntry.Value.DataAs<Ai.Vector3D>().Value;
-                            property = new UserVector3Property( metadataEntry.Key, new Vector3( data.X, data.Y, data.Z ) );
-                            break;
-                        default:
-                            throw new ArgumentOutOfRangeException();
-                    }
-                }
-
-                if ( property == null )
-                {
-                    throw new Exception( "Property shouldn't be null" );
-                }
-
-                node.Properties.Add( property.Name, property );
-            }
-        }
-
-        private static void ProcessAssimpNodeMeshesRecursively( Ai.Node aiNode, Ai.Scene aiScene, Dictionary<string, NodeInfo> nodeLookup, ref int nextBoneIndex, Dictionary<int, List<int>> nodeToBoneIndices, List<Matrix4x4> boneInverseBindMatrices, List<Vector3> transformedVertices, ModelConverterOptions options )
-        {
-            if ( aiNode.HasMeshes )
-            {
-                var nodeInfo = nodeLookup[ AssimpConverterCommon.UnescapeName( aiNode.Name ) ];
-                var node = nodeInfo.Node;
-                var nodeWorldTransform = node.WorldTransform;
-                Matrix4x4.Invert( nodeWorldTransform, out var nodeInverseWorldTransform );
-
-                foreach ( var aiMeshIndex in aiNode.MeshIndices )
-                {
-                    var aiMesh = aiScene.Meshes[aiMeshIndex];
-                    var aiMaterial = aiScene.Materials[aiMesh.MaterialIndex];
-                    var geometry = ConvertAssimpMeshToGeometry( aiMesh, aiMaterial, nodeLookup, ref nextBoneIndex, nodeToBoneIndices, boneInverseBindMatrices, ref nodeWorldTransform, ref nodeInverseWorldTransform, transformedVertices, options );
-
-                    if ( !nodeInfo.IsMeshAttachment )
-                    {
-                        node.Attachments.Add( new NodeMeshAttachment( geometry ) );
-                    }
-                    else
-                    {
-                        node.Parent.Attachments.Add( new NodeMeshAttachment( geometry ) );
-                        node.Parent.RemoveChildNode( node );
-                    }
-                }
-            }
-
-            foreach ( var aiNodeChild in aiNode.Children )
-            {
-                ProcessAssimpNodeMeshesRecursively( aiNodeChild, aiScene, nodeLookup, ref nextBoneIndex, nodeToBoneIndices, boneInverseBindMatrices, transformedVertices, options );
-            }
-        }
-
-        private static Mesh ConvertAssimpMeshToGeometry( Ai.Mesh aiMesh, Ai.Material material, Dictionary<string, NodeInfo> nodeLookup, ref int nextBoneIndex, Dictionary<int, List<int>> nodeToBoneIndices, List<Matrix4x4> boneInverseBindMatrices, ref Matrix4x4 nodeWorldTransform, ref Matrix4x4 nodeInverseWorldTransform, List<Vector3> transformedVertices, ModelConverterOptions options )
-        {
-            if ( !aiMesh.HasVertices )
-                throw new Exception( "Assimp mesh has no vertices" );
-
-            var geometry = new Mesh();
-            var geometryTransformedVertices = new Vector3[ aiMesh.VertexCount ];
-
-            geometry.Vertices = aiMesh.Vertices
-                                      .Select( x => new Vector3( x.X, x.Y, x.Z ) )
-                                      .ToArray();
-
-            for ( int i = 0; i < geometry.Vertices.Length; i++ )
-                geometryTransformedVertices[ i ] = Vector3.Transform( geometry.Vertices[ i ], nodeWorldTransform );
-
-            transformedVertices.AddRange( geometryTransformedVertices );
-
-            if ( aiMesh.HasNormals )
-            {
-                geometry.Normals = aiMesh.Normals
-                                         .Select( x => new Vector3( x.X, x.Y, x.Z ) )
-                                         .ToArray();
-            }
-
-
-            if (aiMesh.HasTangentBasis)
-            {
-                geometry.Tangents = aiMesh.Tangents
-                                         .Select(x => new Vector3(x.X, x.Y, x.Z))
-                                         .ToArray();
-            }
-
-            if ( aiMesh.HasTextureCoords( 0 ) )
-            {
-                geometry.TexCoordsChannel0 = aiMesh.TextureCoordinateChannels[0]
-                                                   .Select( x => new Vector2( x.X, x.Y ) )
-                                                   .ToArray();
-            }
-
-            if ( aiMesh.HasTextureCoords( 1 ) && !options.MinimalVertexAttributes )
-            {
-                geometry.TexCoordsChannel1 = aiMesh.TextureCoordinateChannels[1]
-                                                   .Select( x => new Vector2( x.X, x.Y ) )
-                                                   .ToArray();
-            }
-
-            if ( aiMesh.HasTextureCoords( 2) && !options.MinimalVertexAttributes )
-            {
-                geometry.TexCoordsChannel2 = aiMesh.TextureCoordinateChannels[2]
-                                                   .Select( x => new Vector2( x.X, x.Y ) )
-                                                   .ToArray();
-            }
-
-            if ( aiMesh.HasVertexColors( 0) && !options.MinimalVertexAttributes)
-            {
-                geometry.ColorChannel0 = aiMesh.VertexColorChannels[ 0 ]
-                                               .Select( x => ( uint ) ( ( byte ) ( x.B * 255f ) | ( byte ) ( x.G * 255f ) << 8 | ( byte ) ( x.R * 255f ) << 16 | ( byte ) ( x.A * 255f ) << 24 ) )
-                                               .ToArray();
-            }
-            else if ( options.GenerateVertexColors )
-            {
-                geometry.ColorChannel0 = new uint[geometry.VertexCount];
-                for ( int i = 0; i < geometry.ColorChannel0.Length; i++ )
-                    geometry.ColorChannel0[i] = 0xFFFFFFFF;
-            }
-
-            if ( aiMesh.HasVertexColors( 1) && !options.MinimalVertexAttributes)
-            {
-                geometry.ColorChannel1 = aiMesh.VertexColorChannels[1]
-                                               .Select( x => ( uint )( ( byte )( x.B * 255f ) | ( byte )( x.G * 255f ) << 8 | ( byte )( x.R * 255f ) << 16 | ( byte )( x.A * 255f ) << 24 ) )
-                                               .ToArray();
-            }
-
-            if ( aiMesh.HasFaces )
-            {
-                geometry.TriangleIndexFormat = aiMesh.VertexCount <= ushort.MaxValue ? TriangleIndexFormat.UInt16 : TriangleIndexFormat.UInt32;
-                geometry.Triangles = aiMesh.Faces
-                                           .Select( x => new Triangle( ( uint )x.Indices[0], ( uint )x.Indices[1], ( uint )x.Indices[2] ) )
-                                           .ToArray();
-            }
-
-            if ( aiMesh.HasBones )
-            {
-                geometry.VertexWeights = new VertexWeight[geometry.VertexCount];
-                for ( int i = 0; i < geometry.VertexWeights.Length; i++ )
-                {
-                    geometry.VertexWeights[i].Indices = new byte[4];
-                    geometry.VertexWeights[i].Weights = new float[4];
-                }
-
-                var vertexWeightCounts = new int[geometry.VertexCount];
-
-                for ( var i = 0; i < aiMesh.Bones.Count; i++ )
-                {
-                    var aiMeshBone = aiMesh.Bones[i];
-
-                    // Find node index for the bone
-                    var boneLookupData = nodeLookup[ AssimpConverterCommon.UnescapeName( aiMeshBone.Name ) ];
-                    int nodeIndex = boneLookupData.Index;
-
-                    // Calculate inverse bind matrix
-                    var boneNode = boneLookupData.Node;
-                    var bindMatrix = boneNode.WorldTransform * nodeInverseWorldTransform;
+//             if ( !IsMeshAttachmentNode( aiNode ) )
+//             {
+//                 // Convert properties
+//                 ConvertAssimpMetadataToProperties( aiNode.Metadata, node );
+
+//                 if ( options.SetFullBodyNodeProperties )
+//                 {
+//                     if (node.Name == "See User Defined Properties" )
+//                     {
+//                         TryAddProperty( node.Properties, new UserIntProperty( "NiSortAdjustNode", 0 ) );
+//                     }
+//                     else if ( node.Name.EndsWith( "root" ) || node.Name == "Bip01" )
+//                     {
+//                         TryAddProperty( node.Properties, new UserIntProperty( "KFAccumRoot", 0 ) );
+//                     }
+//                     else if ( sFullBodyObjectNames.Contains( node.Name ) )
+//                     {
+//                         TryAddFullBodyObjectProperties( node.Properties, node.Name );
+//                     }
+//                 }
+
+//                 if ( options.AutoAddGFDHelperIDs ) // for P5/R
+//                 {
+//                     switch( node.Name )
+//                     {
+//                         case "h_B_BD1":
+//                             TryAddProperty( node.Properties, new UserIntProperty( "gfdHelperID", 501 ) );
+//                             break;
+
+//                         case "h_C_US3":
+//                             TryAddProperty( node.Properties, new UserIntProperty( "gfdHelperID", 3 ) );
+//                             break;
+
+//                         case "h_C_FS1":
+//                             TryAddProperty( node.Properties, new UserIntProperty( "gfdHelperID", 21 ) );
+//                             break;
+
+//                         case "h_M_HR3":
+//                             TryAddProperty( node.Properties, new UserIntProperty( "gfdHelperID", 103 ) );
+//                             break;
+
+//                         case "h_B_KA1":
+//                             TryAddProperty( node.Properties, new UserIntProperty( "gfdHelperID", 502 ) );
+//                             break;
+
+//                         case "h_B_CT1":
+//                             TryAddProperty( node.Properties, new UserIntProperty( "gfdHelperID", 521 ) );
+//                             break;
+
+//                         case "h_C_US2":
+//                             TryAddProperty( node.Properties, new UserIntProperty( "gfdHelperID", 2 ) );
+//                             break;
+
+//                         case "h_C_BS1":
+//                             TryAddProperty( node.Properties, new UserIntProperty( "gfdHelperID", 11 ) );
+//                             break;
+
+//                         case "h_M_HL2":
+//                             TryAddProperty( node.Properties, new UserIntProperty( "gfdHelperID", 152 ) );
+//                             break;
+
+//                         case "h_B_MZ1":
+//                             TryAddProperty( node.Properties, new UserIntProperty( "gfdHelperID", 511 ) );
+//                             break;
+
+//                         case "h_M_HR2":
+//                             TryAddProperty( node.Properties, new UserIntProperty( "gfdHelperID", 102 ) );
+//                             break;
+
+//                         case "h_M_HL1":
+//                             TryAddProperty( node.Properties, new UserIntProperty( "gfdHelperID", 151 ) );
+//                             break;
+
+//                         case "h_M_BC1":
+//                             TryAddProperty( node.Properties, new UserIntProperty( "gfdHelperID", 301 ) );
+//                             break;
+
+//                         case "h_C_US1":
+//                             TryAddProperty( node.Properties, new UserIntProperty( "gfdHelperID", 1 ) );
+//                             break;
+
+//                         case "h_M_HL3":
+//                             TryAddProperty( node.Properties, new UserIntProperty( "gfdHelperID", 153 ) );
+//                             break;
+
+//                         case "h_M_HR1":
+//                             TryAddProperty( node.Properties, new UserIntProperty( "gfdHelperID", 101 ) );
+//                             break;
+
+//                         default:
+//                             break;
+//                     }
+//                 }
+
+//                 if ( !nodeLookup.ContainsKey( node.Name ) )
+//                 {
+//                     // Add to lookup
+//                     nodeLookup.Add( node.Name, new NodeInfo( aiNode, node, nextIndex++, false ) );
+//                 }
+//                 else
+//                 {
+//                     throw new Exception( $"Duplicate node name '{node.Name}'" );
+//                 }
+
+//                 // Is this a camera?
+//                 var index = -1;
+//                 if ( ( index = aiScene.Cameras.FindIndex( x => x.Name == node.Name ) ) != -1 )
+//                 {
+//                     var aiCamera = aiScene.Cameras[ index ];
+//                     var camera = new Camera( -aiCamera.Direction.ToNumerics(), aiCamera.Up.ToNumerics(), aiCamera.Position.ToNumerics(),
+//                         aiCamera.ClipPlaneNear, aiCamera.ClipPlaneFar, MathHelper.RadiansToDegrees( aiCamera.FieldOfview ),
+//                         aiCamera.AspectRatio, 0 
+//                     ) { Version = options.Version };
+
+//                     node.Attachments.Add( new NodeCameraAttachment( camera ) );
+//                 }
+//                 else if ( ( index = aiScene.Lights.FindIndex( x => x.Name == node.Name ) ) != -1 )
+//                 {
+//                     var aiLight = aiScene.Lights[ index ];
+//                     var lightType = LightType.Point;
+//                     switch ( aiLight.LightType )
+//                     {
+//                         case Ai.LightSourceType.Directional:
+//                             lightType = LightType.Type1;
+//                             break;
+//                         case Ai.LightSourceType.Point:
+//                         case Ai.LightSourceType.Ambient:
+//                             lightType = LightType.Point;
+//                             break;
+//                         case Ai.LightSourceType.Spot:
+//                             lightType = LightType.Spot;
+//                             break;
+//                     }
+
+//                     var light = new Light
+//                     {
+//                         Version = options.Version,
+//                         AmbientColor   = aiLight.ColorAmbient.ToNumerics(),
+//                         DiffuseColor   = aiLight.ColorDiffuse.ToNumerics(),
+//                         SpecularColor  = aiLight.ColorSpecular.ToNumerics(),
+//                         AngleInnerCone = aiLight.AngleInnerCone,
+//                         AngleOuterCone = aiLight.AngleOuterCone,
+//                         Type           = lightType,
+//                         Flags          = LightFlags.Bit1 | LightFlags.Bit2
+//                     };
+//                     node.Attachments.Add( new NodeLightAttachment( light ) );
+//                 }
+
+//                 // Process children
+//                 foreach ( var aiNodeChild in aiNode.Children )
+//                 {
+//                     if ( aiNodeChild.Name == "RootNode" )
+//                     {
+//                         // For compatibility with old exports 
+//                         // Merge children of 'RootNode' node with actual root node
+//                         foreach ( var aiFakeRootNodeChild in aiNodeChild.Children )
+//                         {
+//                             var childNode = ConvertAssimpNodeRecursively( aiScene, aiFakeRootNodeChild, nodeLookup, ref nextIndex, options );
+//                             node.AddChildNode( childNode );
+//                         }
+//                     }
+//                     else
+//                     {
+//                         var childNode = ConvertAssimpNodeRecursively( aiScene, aiNodeChild, nodeLookup, ref nextIndex, options );
+//                         node.AddChildNode( childNode );
+//                     }
+//                 }
+//             }
+//             else
+//             {
+//                 nodeLookup.Add( node.Name, new NodeInfo( aiNode, node, -1, true ) );
+//             }
+
+//             return node;
+//         }
+
+//         private static void ConvertAssimpMetadataToProperties( Ai.Metadata metadata, Node node )
+//         {
+//             foreach ( var metadataEntry in metadata )
+//             {
+//                 UserProperty property = null;
+
+//                 // Skip some garbage entries
+//                 if ( metadataEntry.Key == "IsNull" ||
+//                      metadataEntry.Key == "InheritType" ||
+//                      metadataEntry.Key == "DefaultAttributeIndex" ||
+//                      metadataEntry.Key == "UserProperties" || // dupe of UDP3DSMAX
+//                      metadataEntry.Key == "ScalingMax" ||
+//                      metadataEntry.Key == "MaxHandle" )
+//                 {
+//                     continue;
+//                 }
+
+//                 if ( metadataEntry.Key == "UDP3DSMAX" )
+//                 {
+//                     var properties = ( ( string )metadataEntry.Value.Data )
+//                         .Split( new[] { "&cr;&lf;", "\r\n", "\n" }, StringSplitOptions.RemoveEmptyEntries );
+
+//                     if ( properties.Length == 0 )
+//                         continue;
+
+//                     foreach ( var propertyString in properties )
+//                     {
+//                         // Parse property string
+//                         KeyValuePair<string, string> kvp;
+//                         if ( propertyString.Contains( '=' ) )
+//                         {
+//                             var split = propertyString.Split( '=' );
+//                             kvp = new KeyValuePair<string, string>( split[0].TrimEnd(), split[1].TrimStart() );
+//                         }
+//                         else
+//                         {
+//                             var split = propertyString.Split( ' ' );
+//                             kvp = new KeyValuePair<string, string>( split[0], split.Length > 1 ? split[1] : null );
+//                         }
+
+//                         // Parse value
+//                         if ( kvp.Value == null )
+//                         {
+//                             // Assume flag bool
+//                             property = new UserBoolProperty( kvp.Key, true );
+//                         }
+//                         else if ( kvp.Value.StartsWith( "[" ) && kvp.Value.EndsWith( "]" ) )
+//                         {
+//                             // Array/Vector
+//                             var arrayContents = kvp.Value.Substring( 1, kvp.Value.Length - 2 );
+//                             var arrayValues = arrayContents.Split( new[] { ',' }, StringSplitOptions.RemoveEmptyEntries );
+
+//                             var arrayFloatValues = new List<float>();
+//                             foreach ( var arrayValue in arrayValues )
+//                             {
+//                                 if ( !float.TryParse( arrayValue, out var arrayFloatValue ) )
+//                                 {
+//                                     throw new Exception( $"Failed to parse array user property value as float: {arrayValue}" );
+//                                 }
+
+//                                 arrayFloatValues.Add( arrayFloatValue );
+//                             }
+
+//                             if ( arrayFloatValues.Count == 3 )
+//                             {
+//                                 property = new UserVector3Property( kvp.Key, new Vector3( arrayFloatValues[0], arrayFloatValues[1], arrayFloatValues[2] ) );
+//                             }
+//                             else if ( arrayFloatValues.Count == 4 )
+//                             {
+//                                 property = new UserVector4Property( kvp.Key, new Vector4( arrayFloatValues[0], arrayFloatValues[1], arrayFloatValues[2], arrayFloatValues[3] ) );
+//                             }
+//                             else
+//                             {
+//                                 var arrayByteValues = arrayFloatValues.Cast<byte>();
+//                                 property = new UserByteArrayProperty( kvp.Key, arrayByteValues.ToArray() );
+//                             }
+//                         }
+//                         else if ( int.TryParse( kvp.Value, out int intValue ) )
+//                         {
+//                             property = new UserIntProperty( kvp.Key, intValue );
+//                         }
+//                         else if ( float.TryParse( kvp.Value, out float floatValue ) )
+//                         {
+//                             property = new UserFloatProperty( kvp.Key, floatValue );
+//                         }
+//                         else if ( bool.TryParse( kvp.Value, out bool boolValue ) )
+//                         {
+//                             property = new UserBoolProperty( kvp.Key, boolValue );
+//                         }
+//                         else
+//                         {
+//                             property = new UserStringProperty( kvp.Key, kvp.Value );
+//                         }
+//                     }
+//                 }
+//                 else
+//                 {
+//                     switch ( metadataEntry.Value.DataType )
+//                     {
+//                         case Ai.MetaDataType.Bool:
+//                             property = new UserBoolProperty( metadataEntry.Key, metadataEntry.Value.DataAs<bool>().Value );
+//                             break;
+//                         case Ai.MetaDataType.Int32:
+//                             property = new UserIntProperty( metadataEntry.Key, metadataEntry.Value.DataAs<int>().Value );
+//                             break;
+//                         case Ai.MetaDataType.UInt64:
+//                             property = new UserByteArrayProperty( metadataEntry.Key, BitConverter.GetBytes( metadataEntry.Value.DataAs<ulong>().Value ) );
+//                             break;
+//                         case Ai.MetaDataType.Float:
+//                             property = new UserFloatProperty( metadataEntry.Key, metadataEntry.Value.DataAs<float>().Value );
+//                             break;
+//                         case Ai.MetaDataType.String:
+//                             property = new UserStringProperty( metadataEntry.Key, ( string )metadataEntry.Value.Data );
+//                             break;
+//                         case Ai.MetaDataType.Vector3D:
+//                             var data = metadataEntry.Value.DataAs<Ai.Vector3D>().Value;
+//                             property = new UserVector3Property( metadataEntry.Key, new Vector3( data.X, data.Y, data.Z ) );
+//                             break;
+//                         default:
+//                             throw new ArgumentOutOfRangeException();
+//                     }
+//                 }
+
+//                 if ( property == null )
+//                 {
+//                     throw new Exception( "Property shouldn't be null" );
+//                 }
+
+//                 node.Properties.Add( property.Name, property );
+//             }
+//         }
+
+//         private static void ProcessAssimpNodeMeshesRecursively( Ai.Node aiNode, Ai.Scene aiScene, Dictionary<string, NodeInfo> nodeLookup, ref int nextBoneIndex, Dictionary<int, List<int>> nodeToBoneIndices, List<Matrix4x4> boneInverseBindMatrices, List<Vector3> transformedVertices, ModelConverterOptions options )
+//         {
+//             if ( aiNode.HasMeshes )
+//             {
+//                 var nodeInfo = nodeLookup[ AssimpConverterCommon.UnescapeName( aiNode.Name ) ];
+//                 var node = nodeInfo.Node;
+//                 var nodeWorldTransform = node.WorldTransform;
+//                 Matrix4x4.Invert( nodeWorldTransform, out var nodeInverseWorldTransform );
+
+//                 foreach ( var aiMeshIndex in aiNode.MeshIndices )
+//                 {
+//                     var aiMesh = aiScene.Meshes[aiMeshIndex];
+//                     var aiMaterial = aiScene.Materials[aiMesh.MaterialIndex];
+//                     var geometry = ConvertAssimpMeshToGeometry( aiMesh, aiMaterial, nodeLookup, ref nextBoneIndex, nodeToBoneIndices, boneInverseBindMatrices, ref nodeWorldTransform, ref nodeInverseWorldTransform, transformedVertices, options );
+
+//                     if ( !nodeInfo.IsMeshAttachment )
+//                     {
+//                         node.Attachments.Add( new NodeMeshAttachment( geometry ) );
+//                     }
+//                     else
+//                     {
+//                         node.Parent.Attachments.Add( new NodeMeshAttachment( geometry ) );
+//                         node.Parent.RemoveChildNode( node );
+//                     }
+//                 }
+//             }
+
+//             foreach ( var aiNodeChild in aiNode.Children )
+//             {
+//                 ProcessAssimpNodeMeshesRecursively( aiNodeChild, aiScene, nodeLookup, ref nextBoneIndex, nodeToBoneIndices, boneInverseBindMatrices, transformedVertices, options );
+//             }
+//         }
+
+//         private static Mesh ConvertAssimpMeshToGeometry( Ai.Mesh aiMesh, Ai.Material material, Dictionary<string, NodeInfo> nodeLookup, ref int nextBoneIndex, Dictionary<int, List<int>> nodeToBoneIndices, List<Matrix4x4> boneInverseBindMatrices, ref Matrix4x4 nodeWorldTransform, ref Matrix4x4 nodeInverseWorldTransform, List<Vector3> transformedVertices, ModelConverterOptions options )
+//         {
+//             if ( !aiMesh.HasVertices )
+//                 throw new Exception( "Assimp mesh has no vertices" );
+
+//             var geometry = new Mesh();
+//             var geometryTransformedVertices = new Vector3[ aiMesh.VertexCount ];
+
+//             geometry.Vertices = aiMesh.Vertices
+//                                       .Select( x => new Vector3( x.X, x.Y, x.Z ) )
+//                                       .ToArray();
+
+//             for ( int i = 0; i < geometry.Vertices.Length; i++ )
+//                 geometryTransformedVertices[ i ] = Vector3.Transform( geometry.Vertices[ i ], nodeWorldTransform );
+
+//             transformedVertices.AddRange( geometryTransformedVertices );
+
+//             if ( aiMesh.HasNormals )
+//             {
+//                 geometry.Normals = aiMesh.Normals
+//                                          .Select( x => new Vector3( x.X, x.Y, x.Z ) )
+//                                          .ToArray();
+//             }
+
+
+//             if (aiMesh.HasTangentBasis)
+//             {
+//                 geometry.Tangents = aiMesh.Tangents
+//                                          .Select(x => new Vector3(x.X, x.Y, x.Z))
+//                                          .ToArray();
+//             }
+
+//             if ( aiMesh.HasTextureCoords( 0 ) )
+//             {
+//                 geometry.TexCoordsChannel0 = aiMesh.TextureCoordinateChannels[0]
+//                                                    .Select( x => new Vector2( x.X, x.Y ) )
+//                                                    .ToArray();
+//             }
+
+//             if ( aiMesh.HasTextureCoords( 1 ) && !options.MinimalVertexAttributes )
+//             {
+//                 geometry.TexCoordsChannel1 = aiMesh.TextureCoordinateChannels[1]
+//                                                    .Select( x => new Vector2( x.X, x.Y ) )
+//                                                    .ToArray();
+//             }
+
+//             if ( aiMesh.HasTextureCoords( 2) && !options.MinimalVertexAttributes )
+//             {
+//                 geometry.TexCoordsChannel2 = aiMesh.TextureCoordinateChannels[2]
+//                                                    .Select( x => new Vector2( x.X, x.Y ) )
+//                                                    .ToArray();
+//             }
+
+//             if ( aiMesh.HasVertexColors( 0) && !options.MinimalVertexAttributes)
+//             {
+//                 geometry.ColorChannel0 = aiMesh.VertexColorChannels[ 0 ]
+//                                                .Select( x => ( uint ) ( ( byte ) ( x.B * 255f ) | ( byte ) ( x.G * 255f ) << 8 | ( byte ) ( x.R * 255f ) << 16 | ( byte ) ( x.A * 255f ) << 24 ) )
+//                                                .ToArray();
+//             }
+//             else if ( options.GenerateVertexColors )
+//             {
+//                 geometry.ColorChannel0 = new uint[geometry.VertexCount];
+//                 for ( int i = 0; i < geometry.ColorChannel0.Length; i++ )
+//                     geometry.ColorChannel0[i] = 0xFFFFFFFF;
+//             }
+
+//             if ( aiMesh.HasVertexColors( 1) && !options.MinimalVertexAttributes)
+//             {
+//                 geometry.ColorChannel1 = aiMesh.VertexColorChannels[1]
+//                                                .Select( x => ( uint )( ( byte )( x.B * 255f ) | ( byte )( x.G * 255f ) << 8 | ( byte )( x.R * 255f ) << 16 | ( byte )( x.A * 255f ) << 24 ) )
+//                                                .ToArray();
+//             }
+
+//             if ( aiMesh.HasFaces )
+//             {
+//                 geometry.TriangleIndexFormat = aiMesh.VertexCount <= ushort.MaxValue ? TriangleIndexFormat.UInt16 : TriangleIndexFormat.UInt32;
+//                 geometry.Triangles = aiMesh.Faces
+//                                            .Select( x => new Triangle( ( uint )x.Indices[0], ( uint )x.Indices[1], ( uint )x.Indices[2] ) )
+//                                            .ToArray();
+//             }
+
+//             if ( aiMesh.HasBones )
+//             {
+//                 geometry.VertexWeights = new VertexWeight[geometry.VertexCount];
+//                 for ( int i = 0; i < geometry.VertexWeights.Length; i++ )
+//                 {
+//                     geometry.VertexWeights[i].Indices = new byte[4];
+//                     geometry.VertexWeights[i].Weights = new float[4];
+//                 }
+
+//                 var vertexWeightCounts = new int[geometry.VertexCount];
+
+//                 for ( var i = 0; i < aiMesh.Bones.Count; i++ )
+//                 {
+//                     var aiMeshBone = aiMesh.Bones[i];
+
+//                     // Find node index for the bone
+//                     var boneLookupData = nodeLookup[ AssimpConverterCommon.UnescapeName( aiMeshBone.Name ) ];
+//                     int nodeIndex = boneLookupData.Index;
+
+//                     // Calculate inverse bind matrix
+//                     var boneNode = boneLookupData.Node;
+//                     var bindMatrix = boneNode.WorldTransform * nodeInverseWorldTransform;
                     
-                    if ( options.ConvertSkinToZUp )
-                        bindMatrix *= YToZUpMatrix;
-
-                    Matrix4x4.Invert( bindMatrix, out var inverseBindMatrix );
-
-                    // Get bone index
-                    int boneIndex;
-                    if ( !nodeToBoneIndices.TryGetValue( nodeIndex, out var boneIndices ) )
-                    {
-                        // No entry for the node was found, so we add a new one
-                        boneIndex = nextBoneIndex++;
-                        nodeToBoneIndices.Add( nodeIndex, new List<int>() { boneIndex } );
-                        boneInverseBindMatrices.Add( inverseBindMatrix );
-                    }
-                    else
-                    {
-                        // Entry for the node was found
-                        // Try to find the bone index based on whether the inverse bind matrix matches
-                        boneIndex = -1;
-                        foreach ( int index in boneIndices )
-                        {
-                            if ( boneInverseBindMatrices[index].Equals( inverseBindMatrix ) )
-                                boneIndex = index;
-                        }
-
-                        if ( boneIndex == -1 )
-                        {
-                            // None matching inverse bind matrix was found, so we add a new entry
-                            boneIndex = nextBoneIndex++;
-                            nodeToBoneIndices[nodeIndex].Add( boneIndex );
-                            boneInverseBindMatrices.Add( inverseBindMatrix );
-                        }
-                    }
-
-                    foreach ( var aiVertexWeight in aiMeshBone.VertexWeights )
-                    {
-                        int vertexWeightCount = vertexWeightCounts[aiVertexWeight.VertexID]++;
-
-                        geometry.VertexWeights[aiVertexWeight.VertexID].Indices[vertexWeightCount] = ( byte )boneIndex;
-                        geometry.VertexWeights[aiVertexWeight.VertexID].Weights[vertexWeightCount] = aiVertexWeight.Weight;
-                    }
-                }
-            }
-
-            geometry.MaterialName = AssimpConverterCommon.UnescapeName( material.Name );
-            geometry.BoundingBox = BoundingBox.Calculate( geometry.Vertices );
-            geometry.BoundingSphere = BoundingSphere.Calculate( geometry.BoundingBox.Value, geometry.Vertices );
-            geometry.Flags |= GeometryFlags.Bit31;
-
-            return geometry;
-        }
-
-        private static List<Bone> BuildBonePalette( List<Matrix4x4> boneInverseBindMatrices, Dictionary<int, List<int>> nodeToBoneIndices )
-        {
-            var usedBones = new List<Bone>();
-
-            for ( int i = 0; i < boneInverseBindMatrices.Count; i++ )
-            {
-                // Reverse dictionary search
-                var boneToNodeIndex = ( ushort ) nodeToBoneIndices
-                                                 .Where( x => x.Value.Contains( i ) )
-                                                 .Select( x => x.Key )
-                                                 .Single();
-
-                var inverseBindMatrix = boneInverseBindMatrices[ i ];
-                usedBones.Add( new Bone( boneToNodeIndex, inverseBindMatrix ) );
-            }
-
-            return usedBones;
-        }
-
-        private struct NodeInfo
-        {
-            public readonly Ai.Node AssimpNode;
-            public readonly Node Node;
-            public readonly int Index;
-            public readonly bool IsMeshAttachment;
-
-            public NodeInfo( Ai.Node aiNode, Node node, int index, bool isMesh )
-            {
-                AssimpNode = aiNode;
-                Node = node;
-                Index = index;
-                IsMeshAttachment = isMesh;
-            }
-        }
-    }
-
-    public class ModelConverterOptions
-    {
-        /// <summary>
-        /// Gets or sets the version to use for the converted resources.
-        /// </summary>
-        public uint Version { get; set; }
-
-        /// <summary>
-        /// Gets or sets whether to convert the up axis of the inverse bind pose matrices to Z-up. This is used by Persona 5's battle models for example.
-        /// </summary>
-        public bool ConvertSkinToZUp { get; set; }
-
-        /// <summary>
-        /// Gets or sets whether to generate dummy (white) vertex colors if they're not already present. Some material shaders rely on vertex colors being present, and the lack of them will cause graphics corruption.
-        /// </summary>
-        public bool GenerateVertexColors { get; set; }
-
-        /// <summary>
-        /// Gets or sets whether to generate dummy (white) vertex colors if they're not already present. Some material shaders rely on vertex colors being present, and the lack of them will cause graphics corruption.
-        /// </summary>
-        public bool MinimalVertexAttributes { get; set; }
-
-        public bool SetFullBodyNodeProperties { get; set; }
-
-        public bool AutoAddGFDHelperIDs { get; set; }
-
-        public ModelConverterOptions()
-        {
-            Version = ResourceVersion.Persona5;
-            ConvertSkinToZUp = false;
-            GenerateVertexColors = false;
-            MinimalVertexAttributes = true;
-            SetFullBodyNodeProperties = false;
-        }
-    }
-}
+//                     if ( options.ConvertSkinToZUp )
+//                         bindMatrix *= YToZUpMatrix;
+
+//                     Matrix4x4.Invert( bindMatrix, out var inverseBindMatrix );
+
+//                     // Get bone index
+//                     int boneIndex;
+//                     if ( !nodeToBoneIndices.TryGetValue( nodeIndex, out var boneIndices ) )
+//                     {
+//                         // No entry for the node was found, so we add a new one
+//                         boneIndex = nextBoneIndex++;
+//                         nodeToBoneIndices.Add( nodeIndex, new List<int>() { boneIndex } );
+//                         boneInverseBindMatrices.Add( inverseBindMatrix );
+//                     }
+//                     else
+//                     {
+//                         // Entry for the node was found
+//                         // Try to find the bone index based on whether the inverse bind matrix matches
+//                         boneIndex = -1;
+//                         foreach ( int index in boneIndices )
+//                         {
+//                             if ( boneInverseBindMatrices[index].Equals( inverseBindMatrix ) )
+//                                 boneIndex = index;
+//                         }
+
+//                         if ( boneIndex == -1 )
+//                         {
+//                             // None matching inverse bind matrix was found, so we add a new entry
+//                             boneIndex = nextBoneIndex++;
+//                             nodeToBoneIndices[nodeIndex].Add( boneIndex );
+//                             boneInverseBindMatrices.Add( inverseBindMatrix );
+//                         }
+//                     }
+
+//                     foreach ( var aiVertexWeight in aiMeshBone.VertexWeights )
+//                     {
+//                         int vertexWeightCount = vertexWeightCounts[aiVertexWeight.VertexID]++;
+
+//                         geometry.VertexWeights[aiVertexWeight.VertexID].Indices[vertexWeightCount] = ( byte )boneIndex;
+//                         geometry.VertexWeights[aiVertexWeight.VertexID].Weights[vertexWeightCount] = aiVertexWeight.Weight;
+//                     }
+//                 }
+//             }
+
+//             geometry.MaterialName = AssimpConverterCommon.UnescapeName( material.Name );
+//             geometry.BoundingBox = BoundingBox.Calculate( geometry.Vertices );
+//             geometry.BoundingSphere = BoundingSphere.Calculate( geometry.BoundingBox.Value, geometry.Vertices );
+//             geometry.Flags |= GeometryFlags.Bit31;
+
+//             return geometry;
+//         }
+
+//         private static List<Bone> BuildBonePalette( List<Matrix4x4> boneInverseBindMatrices, Dictionary<int, List<int>> nodeToBoneIndices )
+//         {
+//             var usedBones = new List<Bone>();
+
+//             for ( int i = 0; i < boneInverseBindMatrices.Count; i++ )
+//             {
+//                 // Reverse dictionary search
+//                 var boneToNodeIndex = ( ushort ) nodeToBoneIndices
+//                                                  .Where( x => x.Value.Contains( i ) )
+//                                                  .Select( x => x.Key )
+//                                                  .Single();
+
+//                 var inverseBindMatrix = boneInverseBindMatrices[ i ];
+//                 usedBones.Add( new Bone( boneToNodeIndex, inverseBindMatrix ) );
+//             }
+
+//             return usedBones;
+//         }
+
+//         private struct NodeInfo
+//         {
+//             public readonly Ai.Node AssimpNode;
+//             public readonly Node Node;
+//             public readonly int Index;
+//             public readonly bool IsMeshAttachment;
+
+//             public NodeInfo( Ai.Node aiNode, Node node, int index, bool isMesh )
+//             {
+//                 AssimpNode = aiNode;
+//                 Node = node;
+//                 Index = index;
+//                 IsMeshAttachment = isMesh;
+//             }
+//         }
+//     }
+
+//     public class ModelConverterOptions
+//     {
+//         /// <summary>
+//         /// Gets or sets the version to use for the converted resources.
+//         /// </summary>
+//         public uint Version { get; set; }
+
+//         /// <summary>
+//         /// Gets or sets whether to convert the up axis of the inverse bind pose matrices to Z-up. This is used by Persona 5's battle models for example.
+//         /// </summary>
+//         public bool ConvertSkinToZUp { get; set; }
+
+//         /// <summary>
+//         /// Gets or sets whether to generate dummy (white) vertex colors if they're not already present. Some material shaders rely on vertex colors being present, and the lack of them will cause graphics corruption.
+//         /// </summary>
+//         public bool GenerateVertexColors { get; set; }
+
+//         /// <summary>
+//         /// Gets or sets whether to generate dummy (white) vertex colors if they're not already present. Some material shaders rely on vertex colors being present, and the lack of them will cause graphics corruption.
+//         /// </summary>
+//         public bool MinimalVertexAttributes { get; set; }
+
+//         public bool SetFullBodyNodeProperties { get; set; }
+
+//         public bool AutoAddGFDHelperIDs { get; set; }
+
+//         public ModelConverterOptions()
+//         {
+//             Version = ResourceVersion.Persona5;
+//             ConvertSkinToZUp = false;
+//             GenerateVertexColors = false;
+//             MinimalVertexAttributes = true;
+//             SetFullBodyNodeProperties = false;
+//         }
+//     }
+// }
diff --git a/GFDLibrary/Models/Conversion/ModelPackConverter.cs b/GFDLibrary/Models/Conversion/ModelPackConverter.cs
index f71c45b..3c9b074 100644
--- a/GFDLibrary/Models/Conversion/ModelPackConverter.cs
+++ b/GFDLibrary/Models/Conversion/ModelPackConverter.cs
@@ -1,178 +1,178 @@
-﻿using System;
-using System.Diagnostics;
-using System.Drawing;
-using System.IO;
-using GFDLibrary.Materials;
-using GFDLibrary.Textures;
-using Ai = Assimp;
-
-namespace GFDLibrary.Models.Conversion
-{
-    public static class ModelPackConverter
-    {
-        public static ModelPack ConvertFromAssimpScene( string filePath, ModelPackConverterOptions options )
-        {
-            // For importing textures
-            string baseDirectoryPath = Path.GetDirectoryName( filePath );
-
-            // Import scene
-            var aiScene = AssimpSceneImporter.ImportFile( filePath );
-
-            // Build textures & Materials
-            var model = new ModelPack( options.Version );
-            model.Textures = new TextureDictionary( options.Version );
-            model.Materials = new MaterialDictionary( options.Version );
-
-            foreach ( var aiSceneMaterial in aiScene.Materials )
-            {
-                var optionsTemp = options;
-                Material mat = ConvertMaterialAndTextures( aiSceneMaterial, optionsTemp, baseDirectoryPath, model.Textures );
-                model.Materials.Add( mat );
-
-                Trace.TraceInformation( "ModelPackConverter -> Material added: " + mat );
-            }
-
-            // Create scene
-            var sceneConverterOptions = new ModelConverterOptions()
-            {
-                Version = options.Version,
-                ConvertSkinToZUp = options.ConvertSkinToZUp,
-                GenerateVertexColors = options.GenerateVertexColors,
-                MinimalVertexAttributes = options.MinimalVertexAttributes,
-                AutoAddGFDHelperIDs = options.AutoAddGFDHelperIDs,
-            };
-
-            model.Model = ModelConverter.ConvertFromAssimpScene( aiScene, sceneConverterOptions );
-
-            return model;
-        }
-
-        private static Material ConvertMaterialAndTextures( Ai.Material aiMaterial, ModelPackConverterOptions options, string baseDirectoryPath, TextureDictionary textureDictionary )
-        {
-            // Convert all textures
-            TextureInfo diffuseTexture = null;
-            if ( aiMaterial.HasTextureDiffuse )
-                diffuseTexture = ConvertTexture( aiMaterial.TextureDiffuse, baseDirectoryPath );
-
-            TextureInfo lightmapTexture = null;
-            if ( aiMaterial.HasTextureLightMap )
-                lightmapTexture = ConvertTexture( aiMaterial.TextureLightMap, baseDirectoryPath );
-
-            TextureInfo displacementTexture = null;
-            if ( aiMaterial.HasTextureDisplacement )
-                displacementTexture = ConvertTexture( aiMaterial.TextureDisplacement, baseDirectoryPath );
-
-            TextureInfo opacityTexture = null;
-            if ( aiMaterial.HasTextureOpacity )
-                opacityTexture = ConvertTexture( aiMaterial.TextureOpacity, baseDirectoryPath );
-
-            TextureInfo normalTexture = null;
-            if ( aiMaterial.HasTextureNormal )
-                normalTexture = ConvertTexture( aiMaterial.TextureNormal, baseDirectoryPath );
-
-            TextureInfo heightTexture = null;
-            if ( aiMaterial.HasTextureHeight )
-                heightTexture = ConvertTexture( aiMaterial.TextureHeight, baseDirectoryPath );
-
-            TextureInfo emissiveTexture = null;
-            if ( aiMaterial.HasTextureEmissive )
-                emissiveTexture = ConvertTexture( aiMaterial.TextureEmissive, baseDirectoryPath );
-
-            TextureInfo ambientTexture = null;
-            if ( aiMaterial.HasTextureAmbient )
-                ambientTexture = ConvertTexture( aiMaterial.TextureAmbient, baseDirectoryPath );
-
-            TextureInfo specularTexture = null;
-            if ( aiMaterial.HasTextureSpecular )
-                specularTexture = ConvertTexture( aiMaterial.TextureSpecular, baseDirectoryPath );
-
-            TextureInfo reflectionTexture = null;
-            if ( aiMaterial.HasTextureReflection )
-                reflectionTexture = ConvertTexture( aiMaterial.TextureReflection, baseDirectoryPath );
-
-            // Convert material
-            string materialName = AssimpConverterCommon.UnescapeName( aiMaterial.Name );
-            Material material = new Material( materialName );
-
-            if ( diffuseTexture != null )
-            {
-                textureDictionary.Add( diffuseTexture.Texture );
-                material = MaterialFactory.CreateMaterial( materialName, diffuseTexture.Name, options ); 
-            }
-
-            return material;
-        }
-
-        private static TextureInfo ConvertTexture( Ai.TextureSlot aiTextureSlot, string baseDirectoryPath )
-        {
-            var relativeFilePath = aiTextureSlot.FilePath;
-            var fullFilePath = Path.GetFullPath( Path.Combine( baseDirectoryPath, relativeFilePath ) );
-            var textureName = AssimpConverterCommon.UnescapeName( Path.GetFileNameWithoutExtension( relativeFilePath ) + ".dds" );
-
-            Texture texture;
-            if ( !File.Exists( fullFilePath ) )
-            {
-                texture = Texture.CreateDefaultTexture( textureName );
-            }
-            else if ( relativeFilePath.EndsWith( ".dds", StringComparison.InvariantCultureIgnoreCase ) )
-            {
-                texture = new Texture( textureName, TextureFormat.DDS, File.ReadAllBytes( fullFilePath ) );
-
-            }
-            else
-            {
-                var bitmap = new Bitmap( fullFilePath );
-                texture = TextureEncoder.Encode( textureName, TextureFormat.DDS, bitmap );
-            }
-
-            return TextureInfo.GetTextureInfo( texture );
-        }
-
-        private static bool HasAlpha( TexturePixelFormat pixelFormat )
-        {
-            return pixelFormat == TexturePixelFormat.BC2 || pixelFormat == TexturePixelFormat.BC3;
-        }
-    }
-
-    public class ModelPackConverterOptions
-    {
-        /// <summary>
-        /// Gets or sets the material preset that should be used while converting the materials.
-        /// </summary>
-        public object MaterialPreset { get; set; }
-
-        /// <summary>
-        /// Gets or sets the version to use for the converted resources.
-        /// </summary>
-        public uint Version { get; set; }
-
-        /// <summary>
-        /// Gets or sets whether to convert the up axis of the inverse bind pose matrices to Z-up. This is used by Persona 5's battle models for example.
-        /// </summary>
-        public bool ConvertSkinToZUp { get; set; }
-
-        /// <summary>
-        /// Gets or sets whether to generate dummy (white) vertex colors if they're not already present. Some material shaders rely on vertex colors being present, and the lack of them will cause graphics corruption.
-        /// </summary>
-        public bool GenerateVertexColors { get; set; }
-
-        /// <summary>
-        /// Sometimes extra vertex attributes are generated for one reason or another, on games using the GFD formats after P5 this causes problems if the data for the attributes does not exist, this sets the minimal amount of attributes to circumvent this issue.
-        /// </summary>
-        public bool MinimalVertexAttributes { get; set; }
-
-        /// <summary>
-        /// If, for whatever reason, the GFD Helper IDs are missing, we try to add them
-        /// </summary>
-        public bool AutoAddGFDHelperIDs { get; set; }
-
-        public ModelPackConverterOptions()
-        {
-            // MaterialPreset = MaterialPreset.CharacterSkinP5;
-            Version = ResourceVersion.Persona5;
-            ConvertSkinToZUp = false;
-            GenerateVertexColors = false;
-            MinimalVertexAttributes = true;
-        }
-    }
-}
+﻿// using System;
+// using System.Diagnostics;
+// using System.Drawing;
+// using System.IO;
+// using GFDLibrary.Materials;
+// using GFDLibrary.Textures;
+// using Ai = Assimp;
+
+// namespace GFDLibrary.Models.Conversion
+// {
+//     public static class ModelPackConverter
+//     {
+//         public static ModelPack ConvertFromAssimpScene( string filePath, ModelPackConverterOptions options )
+//         {
+//             // For importing textures
+//             string baseDirectoryPath = Path.GetDirectoryName( filePath );
+
+//             // Import scene
+//             var aiScene = AssimpSceneImporter.ImportFile( filePath );
+
+//             // Build textures & Materials
+//             var model = new ModelPack( options.Version );
+//             model.Textures = new TextureDictionary( options.Version );
+//             model.Materials = new MaterialDictionary( options.Version );
+
+//             foreach ( var aiSceneMaterial in aiScene.Materials )
+//             {
+//                 var optionsTemp = options;
+//                 Material mat = ConvertMaterialAndTextures( aiSceneMaterial, optionsTemp, baseDirectoryPath, model.Textures );
+//                 model.Materials.Add( mat );
+
+//                 Trace.TraceInformation( "ModelPackConverter -> Material added: " + mat );
+//             }
+
+//             // Create scene
+//             var sceneConverterOptions = new ModelConverterOptions()
+//             {
+//                 Version = options.Version,
+//                 ConvertSkinToZUp = options.ConvertSkinToZUp,
+//                 GenerateVertexColors = options.GenerateVertexColors,
+//                 MinimalVertexAttributes = options.MinimalVertexAttributes,
+//                 AutoAddGFDHelperIDs = options.AutoAddGFDHelperIDs,
+//             };
+
+//             model.Model = ModelConverter.ConvertFromAssimpScene( aiScene, sceneConverterOptions );
+
+//             return model;
+//         }
+
+//         private static Material ConvertMaterialAndTextures( Ai.Material aiMaterial, ModelPackConverterOptions options, string baseDirectoryPath, TextureDictionary textureDictionary )
+//         {
+//             // Convert all textures
+//             TextureInfo diffuseTexture = null;
+//             if ( aiMaterial.HasTextureDiffuse )
+//                 diffuseTexture = ConvertTexture( aiMaterial.TextureDiffuse, baseDirectoryPath );
+
+//             TextureInfo lightmapTexture = null;
+//             if ( aiMaterial.HasTextureLightMap )
+//                 lightmapTexture = ConvertTexture( aiMaterial.TextureLightMap, baseDirectoryPath );
+
+//             TextureInfo displacementTexture = null;
+//             if ( aiMaterial.HasTextureDisplacement )
+//                 displacementTexture = ConvertTexture( aiMaterial.TextureDisplacement, baseDirectoryPath );
+
+//             TextureInfo opacityTexture = null;
+//             if ( aiMaterial.HasTextureOpacity )
+//                 opacityTexture = ConvertTexture( aiMaterial.TextureOpacity, baseDirectoryPath );
+
+//             TextureInfo normalTexture = null;
+//             if ( aiMaterial.HasTextureNormal )
+//                 normalTexture = ConvertTexture( aiMaterial.TextureNormal, baseDirectoryPath );
+
+//             TextureInfo heightTexture = null;
+//             if ( aiMaterial.HasTextureHeight )
+//                 heightTexture = ConvertTexture( aiMaterial.TextureHeight, baseDirectoryPath );
+
+//             TextureInfo emissiveTexture = null;
+//             if ( aiMaterial.HasTextureEmissive )
+//                 emissiveTexture = ConvertTexture( aiMaterial.TextureEmissive, baseDirectoryPath );
+
+//             TextureInfo ambientTexture = null;
+//             if ( aiMaterial.HasTextureAmbient )
+//                 ambientTexture = ConvertTexture( aiMaterial.TextureAmbient, baseDirectoryPath );
+
+//             TextureInfo specularTexture = null;
+//             if ( aiMaterial.HasTextureSpecular )
+//                 specularTexture = ConvertTexture( aiMaterial.TextureSpecular, baseDirectoryPath );
+
+//             TextureInfo reflectionTexture = null;
+//             if ( aiMaterial.HasTextureReflection )
+//                 reflectionTexture = ConvertTexture( aiMaterial.TextureReflection, baseDirectoryPath );
+
+//             // Convert material
+//             string materialName = AssimpConverterCommon.UnescapeName( aiMaterial.Name );
+//             Material material = new Material( materialName );
+
+//             if ( diffuseTexture != null )
+//             {
+//                 textureDictionary.Add( diffuseTexture.Texture );
+//                 material = MaterialFactory.CreateMaterial( materialName, diffuseTexture.Name, options ); 
+//             }
+
+//             return material;
+//         }
+
+//         private static TextureInfo ConvertTexture( Ai.TextureSlot aiTextureSlot, string baseDirectoryPath )
+//         {
+//             var relativeFilePath = aiTextureSlot.FilePath;
+//             var fullFilePath = Path.GetFullPath( Path.Combine( baseDirectoryPath, relativeFilePath ) );
+//             var textureName = AssimpConverterCommon.UnescapeName( Path.GetFileNameWithoutExtension( relativeFilePath ) + ".dds" );
+
+//             Texture texture;
+//             if ( !File.Exists( fullFilePath ) )
+//             {
+//                 texture = Texture.CreateDefaultTexture( textureName );
+//             }
+//             else if ( relativeFilePath.EndsWith( ".dds", StringComparison.InvariantCultureIgnoreCase ) )
+//             {
+//                 texture = new Texture( textureName, TextureFormat.DDS, File.ReadAllBytes( fullFilePath ) );
+
+//             }
+//             else
+//             {
+//                 var bitmap = new Bitmap( fullFilePath );
+//                 texture = TextureEncoder.Encode( textureName, TextureFormat.DDS, bitmap );
+//             }
+
+//             return TextureInfo.GetTextureInfo( texture );
+//         }
+
+//         private static bool HasAlpha( TexturePixelFormat pixelFormat )
+//         {
+//             return pixelFormat == TexturePixelFormat.BC2 || pixelFormat == TexturePixelFormat.BC3;
+//         }
+//     }
+
+//     public class ModelPackConverterOptions
+//     {
+//         /// <summary>
+//         /// Gets or sets the material preset that should be used while converting the materials.
+//         /// </summary>
+//         public object MaterialPreset { get; set; }
+
+//         /// <summary>
+//         /// Gets or sets the version to use for the converted resources.
+//         /// </summary>
+//         public uint Version { get; set; }
+
+//         /// <summary>
+//         /// Gets or sets whether to convert the up axis of the inverse bind pose matrices to Z-up. This is used by Persona 5's battle models for example.
+//         /// </summary>
+//         public bool ConvertSkinToZUp { get; set; }
+
+//         /// <summary>
+//         /// Gets or sets whether to generate dummy (white) vertex colors if they're not already present. Some material shaders rely on vertex colors being present, and the lack of them will cause graphics corruption.
+//         /// </summary>
+//         public bool GenerateVertexColors { get; set; }
+
+//         /// <summary>
+//         /// Sometimes extra vertex attributes are generated for one reason or another, on games using the GFD formats after P5 this causes problems if the data for the attributes does not exist, this sets the minimal amount of attributes to circumvent this issue.
+//         /// </summary>
+//         public bool MinimalVertexAttributes { get; set; }
+
+//         /// <summary>
+//         /// If, for whatever reason, the GFD Helper IDs are missing, we try to add them
+//         /// </summary>
+//         public bool AutoAddGFDHelperIDs { get; set; }
+
+//         public ModelPackConverterOptions()
+//         {
+//             // MaterialPreset = MaterialPreset.CharacterSkinP5;
+//             Version = ResourceVersion.Persona5;
+//             ConvertSkinToZUp = false;
+//             GenerateVertexColors = false;
+//             MinimalVertexAttributes = true;
+//         }
+//     }
+// }
diff --git a/GFDLibrary/Models/Conversion/ModelPackExporter.cs b/GFDLibrary/Models/Conversion/ModelPackExporter.cs
index faf330d..be7f3aa 100644
--- a/GFDLibrary/Models/Conversion/ModelPackExporter.cs
+++ b/GFDLibrary/Models/Conversion/ModelPackExporter.cs
@@ -1,373 +1,373 @@
-﻿using System.Collections.Generic;
-using System.IO;
-using System.Linq;
-using System.Numerics;
-using System.Text;
-using GFDLibrary.Cameras;
-using GFDLibrary.Common;
-using GFDLibrary.Lights;
-using GFDLibrary.Materials;
-using GFDLibrary.Models.Conversion.Utilities;
-using GFDLibrary.Textures;
-using GFDLibrary.Utilities;
-using Ai = Assimp;
-
-namespace GFDLibrary.Models.Conversion
-{
-    public class ModelPackExporter
-    {
-        private Ai.Scene mAiScene;
-        private string mPath;
-        private string mFileName;
-        private string mBaseDirectoryPath;
-        private string mTextureBaseDirectoryPath;
-        private string mTextureBaseRelativeDirectoryPath;
-
-        public static void ExportFile( ModelPack modelPack, string path )
-        {
-            var exporter = new ModelPackExporter();
-            var scene = exporter.ConvertModelPack( modelPack, path );
-            ExportFile( scene, path );
-        }
-
-        public static void ExportFile( Ai.Scene scene, string path )
-        {
-            var aiContext = new Ai.AssimpContext();
-            aiContext.XAxisRotation = 90;
-            aiContext.ExportFile( scene, path, "collada", Ai.PostProcessSteps.FlipUVs );
-        }
-
-        private void Init( string path )
-        {
-            mAiScene = new Ai.Scene();
-            mPath = Path.GetFullPath( path );
-            mFileName = Path.GetFileNameWithoutExtension( mPath );
-            mBaseDirectoryPath = Path.GetDirectoryName( mPath );
-            mTextureBaseDirectoryPath = Path.Combine( mBaseDirectoryPath, $"{mFileName}_Textures" );
-            mTextureBaseRelativeDirectoryPath = mTextureBaseDirectoryPath.Substring( mBaseDirectoryPath.Length );
-        }
-
-        private Ai.Scene ConvertModelPack( ModelPack modelPack, string path )
-        {
-            Init( path );
-
-            if ( modelPack.Textures != null )
-                ConvertTextures( modelPack.Textures );
-
-            if ( modelPack.Materials != null )
-                ConvertMaterials( modelPack.Materials );
-
-            if ( modelPack.Model != null )
-                ConvertModel( modelPack.Model );
-
-            return mAiScene;
-        }
-
-        private void ConvertTextures( TextureDictionary textureDictionary )
-        {
-            Directory.CreateDirectory( mTextureBaseDirectoryPath );
-
-            foreach ( var texture in textureDictionary.Textures )
-            {
-                var texturePath = Path.Combine( mTextureBaseDirectoryPath, AssimpConverterCommon.EscapeName(texture.Name) );
-
-                File.WriteAllBytes( texturePath, texture.Data );
-            }
-        }
-
-        private void ConvertMaterials( MaterialDictionary materialDictionary )
-        {
-            foreach ( var material in materialDictionary.Materials )
-            {
-                mAiScene.Materials.Add( ConvertMaterial( material ) );
-            }
-        }
-
-        private Ai.Material ConvertMaterial( Material material )
-        {
-            var aiMaterial = new Ai.Material
-            {
-                Name = AssimpConverterCommon.EscapeName(material.Name),
-                ColorAmbient = new Ai.Color4D( material.AmbientColor.X, material.AmbientColor.Y, material.AmbientColor.Z, material.AmbientColor.W ),
-                ColorDiffuse = new Ai.Color4D( material.DiffuseColor.X, material.DiffuseColor.Y, material.DiffuseColor.Z, material.DiffuseColor.W ),
-                ColorSpecular = new Ai.Color4D( material.SpecularColor.X, material.SpecularColor.Y, material.SpecularColor.Z, material.SpecularColor.W ),
-                ColorEmissive = new Ai.Color4D( material.EmissiveColor.X, material.EmissiveColor.Y, material.EmissiveColor.Z, material.EmissiveColor.W )
-            };
-
-            if ( material.Flags.HasFlag( MaterialFlags.HasDiffuseMap ) )
-            {
-                aiMaterial.TextureDiffuse = new Ai.TextureSlot( 
-                    Path.Combine( mTextureBaseRelativeDirectoryPath, AssimpConverterCommon.EscapeName(material.DiffuseMap.Name) ),
-                    Ai.TextureType.Diffuse, 0, Ai.TextureMapping.FromUV, 0, 0, Ai.TextureOperation.Add, Ai.TextureWrapMode.Wrap, Ai.TextureWrapMode.Wrap, 0 );
-            }
-
-            if ( material.Flags.HasFlag( MaterialFlags.HasNormalMap ) )
-            {
-                aiMaterial.TextureNormal = new Ai.TextureSlot( 
-                    Path.Combine( mTextureBaseRelativeDirectoryPath, AssimpConverterCommon.EscapeName(material.NormalMap.Name) ), 
-                    Ai.TextureType.Normals, 1, Ai.TextureMapping.FromUV, 0, 0, Ai.TextureOperation.Add, Ai.TextureWrapMode.Wrap, Ai.TextureWrapMode.Wrap, 0 );
-            }
-
-            if ( material.Flags.HasFlag( MaterialFlags.HasSpecularMap ) )
-            {
-                aiMaterial.TextureSpecular = new Ai.TextureSlot( 
-                    Path.Combine( mTextureBaseRelativeDirectoryPath, AssimpConverterCommon.EscapeName(material.SpecularMap.Name) ), 
-                    Ai.TextureType.Specular, 2, Ai.TextureMapping.FromUV, 0, 0, Ai.TextureOperation.Add, Ai.TextureWrapMode.Wrap, Ai.TextureWrapMode.Wrap, 0 );
-            }
-
-            if ( material.Flags.HasFlag( MaterialFlags.HasReflectionMap ) )
-            {
-                aiMaterial.TextureReflection = new Ai.TextureSlot( 
-                    Path.Combine( mTextureBaseRelativeDirectoryPath, AssimpConverterCommon.EscapeName(material.ReflectionMap.Name) ), 
-                    Ai.TextureType.Reflection, 3, Ai.TextureMapping.FromUV, 0, 0, Ai.TextureOperation.Add, Ai.TextureWrapMode.Wrap, Ai.TextureWrapMode.Wrap, 0 );
-            }
-
-            // todo: add more textures
-
-            return aiMaterial;
-        }
-
-        private void ConvertModel( Model model )
-        {
-            mAiScene.RootNode = ConvertNode( model, model.RootNode, null );
-        }
-
-        private Ai.Node ConvertNode( Model model, Node node, Ai.Node aiParent )
-        {
-            var aiNode = new Ai.Node( AssimpConverterCommon.EscapeName( node.Name ), aiParent )
-            {
-                Transform = new Ai.Matrix4x4( node.LocalTransform.M11, node.LocalTransform.M21, node.LocalTransform.M31, node.LocalTransform.M41,
-                                              node.LocalTransform.M12, node.LocalTransform.M22, node.LocalTransform.M32, node.LocalTransform.M42,
-                                              node.LocalTransform.M13, node.LocalTransform.M23, node.LocalTransform.M33, node.LocalTransform.M43,
-                                              node.LocalTransform.M14, node.LocalTransform.M24, node.LocalTransform.M34, node.LocalTransform.M44 )
-            };
-
-            if ( node.HasProperties )
-            {
-                ConvertNodeProperties( node.Properties, aiNode );
-            }
-
-            if ( node.HasAttachments )
-            {
-                ConvertNodeAttachments( model, node, aiNode );
-            }
-
-            if ( node.HasChildren )
-            {
-                foreach ( var childNode in node.Children )
-                {
-                    aiNode.Children.Add( ConvertNode( model, childNode, aiNode ) );
-                }
-            }
-
-            return aiNode;
-        }
-
-        private static void ConvertNodeProperties( UserPropertyDictionary properties, Ai.Node aiNode )
-        {
-            var stringBuilder = new StringBuilder();
-
-            foreach ( var property in properties.Values )
-            {
-                // Todo: Assign to 3ds max user properties
-                stringBuilder.Append( $"{property.ToUserPropertyString()}&cr;&lf;" );
-            }
-
-            aiNode.Metadata["UDP3DSMAX"] = new Ai.Metadata.Entry( Ai.MetaDataType.String, stringBuilder.ToString() );
-        }
-
-        private void ConvertNodeAttachments( Model model, Node node, Ai.Node aiNode )
-        {
-            for ( int i = 0; i < node.Attachments.Count; i++ )
-            {
-                var attachment = node.Attachments[i];
-
-                switch ( attachment.Type )
-                {
-                    case NodeAttachmentType.Mesh:
-                        {
-                            var mesh = ConvertGeometry( model, node, attachment.GetValue<Mesh>() );
-
-                            mesh.Name = $"{AssimpConverterCommon.EscapeName(node.Name)}_Attachment{i}_Mesh";
-                            aiNode.MeshIndices.Add( mAiScene.Meshes.Count );
-                            mAiScene.Meshes.Add( mesh );
-                        }
-                        break;
-
-                    case NodeAttachmentType.Camera:
-                        {
-                            var camera = attachment.GetValue<Camera>();
-                            mAiScene.Cameras.Add( new Ai.Camera
-                            {
-                                Name          = node.Name,
-                                Position      = camera.Position.ToAssimp(),
-                                Up            = camera.Up.ToAssimp(),
-                                Direction     = -camera.Direction.ToAssimp(),
-                                FieldOfview   = MathHelper.DegreesToRadians( camera.FieldOfView ),
-                                ClipPlaneNear = camera.ClipPlaneNear,
-                                ClipPlaneFar  = camera.ClipPlaneFar,
-                                AspectRatio   = camera.AspectRatio
-                            });
-                        }
-                        break;
-
-                    case NodeAttachmentType.Light:
-                        {
-                            var light = attachment.GetValue<Light>();
-                            mAiScene.Lights.Add( new Ai.Light
-                            {
-                                Name = node.Name,
-                                AngleInnerCone = light.AngleInnerCone,
-                                AngleOuterCone = light.AngleOuterCone,
-                                ColorAmbient = light.AmbientColor.ToAssimpAsColor3D(),
-                                ColorDiffuse = light.DiffuseColor.ToAssimpAsColor3D(),
-                                ColorSpecular = light.SpecularColor.ToAssimpAsColor3D(),
-                                LightType = light.Type == LightType.Point ? Ai.LightSourceType.Point : light.Type == LightType.Spot ? Ai.LightSourceType.Spot : Ai.LightSourceType.Directional,
-                            });
-                        }
-                        break;
-                    default:
-                        //throw new NotImplementedException();
-                        break;
-                }
-            }
-        }
-
-        private Ai.Mesh ConvertGeometry( Model model, Node geometryNode, Mesh mesh )
-        {
-            var aiMesh = new Ai.Mesh( Ai.PrimitiveType.Triangle );
-
-            if ( mesh.Flags.HasFlag( GeometryFlags.HasMaterial ) )
-                aiMesh.MaterialIndex = mAiScene.Materials.FindIndex( x => x.Name == AssimpConverterCommon.EscapeName(mesh.MaterialName) );
-
-            if ( mesh.Flags.HasFlag( GeometryFlags.HasTriangles ) )
-            {
-                foreach ( var triangle in mesh.Triangles )
-                {
-                    var aiFace = new Ai.Face();
-                    aiFace.Indices.Add( ( int )triangle.A );
-                    aiFace.Indices.Add( ( int )triangle.B );
-                    aiFace.Indices.Add( ( int )triangle.C );
-                    aiMesh.Faces.Add( aiFace );
-                }
-            }
-
-            var vertices = mesh.Vertices;
-            var normals = mesh.Normals;
-
-            if ( mesh.VertexWeights != null )
-                ( vertices, normals ) = mesh.Transform( geometryNode, model.Nodes.ToList(), model.Bones );
-
-            if ( mesh.VertexAttributeFlags.HasFlag( VertexAttributeFlags.Position ) )
-            {
-                foreach ( var vertex in vertices )
-                {
-                    aiMesh.Vertices.Add( new Ai.Vector3D( vertex.X, vertex.Y, vertex.Z ) );
-                }
-            }
-
-            if ( mesh.VertexAttributeFlags.HasFlag( VertexAttributeFlags.Normal ) )
-            {
-                foreach ( var normal in normals )
-                {
-                    aiMesh.Normals.Add( new Ai.Vector3D( normal.X, normal.Y, normal.Z ) );
-                }
-            }
-
-            if ( mesh.VertexAttributeFlags.HasFlag( VertexAttributeFlags.Tangent ) )
-            {
-                foreach ( var tangent in mesh.Tangents )
-                {
-                    aiMesh.Tangents.Add( new Ai.Vector3D( tangent.X, tangent.Y, tangent.Z ) );
-                }
-            }
-
-            if ( mesh.VertexAttributeFlags.HasFlag( VertexAttributeFlags.Binormal ) )
-            {
-                foreach ( var binormal in mesh.Binormals )
-                {
-                    aiMesh.BiTangents.Add( new Ai.Vector3D( binormal.X, binormal.Y, binormal.Z ) );
-                }
-            }
-
-            if ( mesh.VertexAttributeFlags.HasFlag( VertexAttributeFlags.TexCoord0 ) )
-            {
-                foreach ( var vertex in mesh.TexCoordsChannel0 )
-                {
-                    aiMesh.TextureCoordinateChannels[0].Add( new Ai.Vector3D( vertex.X, vertex.Y, 0 ) );
-                }
-            }
-
-            if ( mesh.VertexAttributeFlags.HasFlag( VertexAttributeFlags.TexCoord1 ) )
-            {
-                foreach ( var vertex in mesh.TexCoordsChannel1 )
-                {
-                    aiMesh.TextureCoordinateChannels[1].Add( new Ai.Vector3D( vertex.X, vertex.Y, 0 ) );
-                }
-            }
-
-            if ( mesh.VertexAttributeFlags.HasFlag( VertexAttributeFlags.TexCoord2 ) )
-            {
-                foreach ( var vertex in mesh.TexCoordsChannel2 )
-                {
-                    aiMesh.TextureCoordinateChannels[2].Add( new Ai.Vector3D( vertex.X, vertex.Y, 0 ) );
-                }
-            }
-
-            /* todo: colors
-            if ( mesh.VertexAttributeFlags.HasFlag( VertexAttributeFlags.Color0 ) )
-            {
-                foreach ( var color in mesh.ColorChannel0 )
-                {
-                    aiMesh.VertexColorChannels[0].Add( new Ai.Color4D( color. ))
-                }
-            }
-            */
-
-            if ( mesh.Flags.HasFlag( GeometryFlags.HasVertexWeights ) )
-            {
-                var boneMap = new Dictionary<int, Ai.Bone>();
-
-                for ( int i = 0; i < mesh.VertexWeights.Length; i++ )
-                {
-                    var vertexWeight = mesh.VertexWeights[i];
-
-                    for ( int j = 0; j < 4; j++ )
-                    {
-                        var boneWeight = vertexWeight.Weights[j];
-                        if ( boneWeight == 0f )
-                            continue;
-
-                        var boneIndex = vertexWeight.Indices[j];
-                        var nodeIndex = model.Bones[boneIndex].NodeIndex;
-
-                        if ( !boneMap.ContainsKey( nodeIndex ) )
-                        {
-                            var aiBone = new Ai.Bone();
-                            var boneNode = model.GetNode( nodeIndex );
-
-                            aiBone.Name = AssimpConverterCommon.EscapeName( boneNode.Name );
-                            aiBone.VertexWeights.Add( new Ai.VertexWeight( i, boneWeight ) );
-
-                            Matrix4x4.Invert( geometryNode.WorldTransform, out Matrix4x4 invGeometryNodeWorldTransform );
-                            Matrix4x4.Invert( boneNode.WorldTransform * invGeometryNodeWorldTransform, out Matrix4x4 offsetMatrix );
-                            aiBone.OffsetMatrix = new Ai.Matrix4x4( offsetMatrix.M11, offsetMatrix.M21, offsetMatrix.M31, offsetMatrix.M41,
-                                                                    offsetMatrix.M12, offsetMatrix.M22, offsetMatrix.M32, offsetMatrix.M42,
-                                                                    offsetMatrix.M13, offsetMatrix.M23, offsetMatrix.M33, offsetMatrix.M43,
-                                                                    offsetMatrix.M14, offsetMatrix.M24, offsetMatrix.M34, offsetMatrix.M44 );
-                            boneMap[nodeIndex] = aiBone;
-                        }
-                        else
-                        {
-                            boneMap[nodeIndex].VertexWeights.Add( new Ai.VertexWeight( i, boneWeight ) );
-                        }
-                    }
-                }
-
-                aiMesh.Bones.AddRange( boneMap.Values );
-            }
-
-            return aiMesh;
-        }
-    }
-}
+﻿// using System.Collections.Generic;
+// using System.IO;
+// using System.Linq;
+// using System.Numerics;
+// using System.Text;
+// using GFDLibrary.Cameras;
+// using GFDLibrary.Common;
+// using GFDLibrary.Lights;
+// using GFDLibrary.Materials;
+// using GFDLibrary.Models.Conversion.Utilities;
+// using GFDLibrary.Textures;
+// using GFDLibrary.Utilities;
+// using Ai = Assimp;
+
+// namespace GFDLibrary.Models.Conversion
+// {
+//     public class ModelPackExporter
+//     {
+//         private Ai.Scene mAiScene;
+//         private string mPath;
+//         private string mFileName;
+//         private string mBaseDirectoryPath;
+//         private string mTextureBaseDirectoryPath;
+//         private string mTextureBaseRelativeDirectoryPath;
+
+//         public static void ExportFile( ModelPack modelPack, string path )
+//         {
+//             var exporter = new ModelPackExporter();
+//             var scene = exporter.ConvertModelPack( modelPack, path );
+//             ExportFile( scene, path );
+//         }
+
+//         public static void ExportFile( Ai.Scene scene, string path )
+//         {
+//             var aiContext = new Ai.AssimpContext();
+//             aiContext.XAxisRotation = 90;
+//             aiContext.ExportFile( scene, path, "collada", Ai.PostProcessSteps.FlipUVs );
+//         }
+
+//         private void Init( string path )
+//         {
+//             mAiScene = new Ai.Scene();
+//             mPath = Path.GetFullPath( path );
+//             mFileName = Path.GetFileNameWithoutExtension( mPath );
+//             mBaseDirectoryPath = Path.GetDirectoryName( mPath );
+//             mTextureBaseDirectoryPath = Path.Combine( mBaseDirectoryPath, $"{mFileName}_Textures" );
+//             mTextureBaseRelativeDirectoryPath = mTextureBaseDirectoryPath.Substring( mBaseDirectoryPath.Length );
+//         }
+
+//         private Ai.Scene ConvertModelPack( ModelPack modelPack, string path )
+//         {
+//             Init( path );
+
+//             if ( modelPack.Textures != null )
+//                 ConvertTextures( modelPack.Textures );
+
+//             if ( modelPack.Materials != null )
+//                 ConvertMaterials( modelPack.Materials );
+
+//             if ( modelPack.Model != null )
+//                 ConvertModel( modelPack.Model );
+
+//             return mAiScene;
+//         }
+
+//         private void ConvertTextures( TextureDictionary textureDictionary )
+//         {
+//             Directory.CreateDirectory( mTextureBaseDirectoryPath );
+
+//             foreach ( var texture in textureDictionary.Textures )
+//             {
+//                 var texturePath = Path.Combine( mTextureBaseDirectoryPath, AssimpConverterCommon.EscapeName(texture.Name) );
+
+//                 File.WriteAllBytes( texturePath, texture.Data );
+//             }
+//         }
+
+//         private void ConvertMaterials( MaterialDictionary materialDictionary )
+//         {
+//             foreach ( var material in materialDictionary.Materials )
+//             {
+//                 mAiScene.Materials.Add( ConvertMaterial( material ) );
+//             }
+//         }
+
+//         private Ai.Material ConvertMaterial( Material material )
+//         {
+//             var aiMaterial = new Ai.Material
+//             {
+//                 Name = AssimpConverterCommon.EscapeName(material.Name),
+//                 ColorAmbient = new Ai.Color4D( material.AmbientColor.X, material.AmbientColor.Y, material.AmbientColor.Z, material.AmbientColor.W ),
+//                 ColorDiffuse = new Ai.Color4D( material.DiffuseColor.X, material.DiffuseColor.Y, material.DiffuseColor.Z, material.DiffuseColor.W ),
+//                 ColorSpecular = new Ai.Color4D( material.SpecularColor.X, material.SpecularColor.Y, material.SpecularColor.Z, material.SpecularColor.W ),
+//                 ColorEmissive = new Ai.Color4D( material.EmissiveColor.X, material.EmissiveColor.Y, material.EmissiveColor.Z, material.EmissiveColor.W )
+//             };
+
+//             if ( material.Flags.HasFlag( MaterialFlags.HasDiffuseMap ) )
+//             {
+//                 aiMaterial.TextureDiffuse = new Ai.TextureSlot( 
+//                     Path.Combine( mTextureBaseRelativeDirectoryPath, AssimpConverterCommon.EscapeName(material.DiffuseMap.Name) ),
+//                     Ai.TextureType.Diffuse, 0, Ai.TextureMapping.FromUV, 0, 0, Ai.TextureOperation.Add, Ai.TextureWrapMode.Wrap, Ai.TextureWrapMode.Wrap, 0 );
+//             }
+
+//             if ( material.Flags.HasFlag( MaterialFlags.HasNormalMap ) )
+//             {
+//                 aiMaterial.TextureNormal = new Ai.TextureSlot( 
+//                     Path.Combine( mTextureBaseRelativeDirectoryPath, AssimpConverterCommon.EscapeName(material.NormalMap.Name) ), 
+//                     Ai.TextureType.Normals, 1, Ai.TextureMapping.FromUV, 0, 0, Ai.TextureOperation.Add, Ai.TextureWrapMode.Wrap, Ai.TextureWrapMode.Wrap, 0 );
+//             }
+
+//             if ( material.Flags.HasFlag( MaterialFlags.HasSpecularMap ) )
+//             {
+//                 aiMaterial.TextureSpecular = new Ai.TextureSlot( 
+//                     Path.Combine( mTextureBaseRelativeDirectoryPath, AssimpConverterCommon.EscapeName(material.SpecularMap.Name) ), 
+//                     Ai.TextureType.Specular, 2, Ai.TextureMapping.FromUV, 0, 0, Ai.TextureOperation.Add, Ai.TextureWrapMode.Wrap, Ai.TextureWrapMode.Wrap, 0 );
+//             }
+
+//             if ( material.Flags.HasFlag( MaterialFlags.HasReflectionMap ) )
+//             {
+//                 aiMaterial.TextureReflection = new Ai.TextureSlot( 
+//                     Path.Combine( mTextureBaseRelativeDirectoryPath, AssimpConverterCommon.EscapeName(material.ReflectionMap.Name) ), 
+//                     Ai.TextureType.Reflection, 3, Ai.TextureMapping.FromUV, 0, 0, Ai.TextureOperation.Add, Ai.TextureWrapMode.Wrap, Ai.TextureWrapMode.Wrap, 0 );
+//             }
+
+//             // todo: add more textures
+
+//             return aiMaterial;
+//         }
+
+//         private void ConvertModel( Model model )
+//         {
+//             mAiScene.RootNode = ConvertNode( model, model.RootNode, null );
+//         }
+
+//         private Ai.Node ConvertNode( Model model, Node node, Ai.Node aiParent )
+//         {
+//             var aiNode = new Ai.Node( AssimpConverterCommon.EscapeName( node.Name ), aiParent )
+//             {
+//                 Transform = new Ai.Matrix4x4( node.LocalTransform.M11, node.LocalTransform.M21, node.LocalTransform.M31, node.LocalTransform.M41,
+//                                               node.LocalTransform.M12, node.LocalTransform.M22, node.LocalTransform.M32, node.LocalTransform.M42,
+//                                               node.LocalTransform.M13, node.LocalTransform.M23, node.LocalTransform.M33, node.LocalTransform.M43,
+//                                               node.LocalTransform.M14, node.LocalTransform.M24, node.LocalTransform.M34, node.LocalTransform.M44 )
+//             };
+
+//             if ( node.HasProperties )
+//             {
+//                 ConvertNodeProperties( node.Properties, aiNode );
+//             }
+
+//             if ( node.HasAttachments )
+//             {
+//                 ConvertNodeAttachments( model, node, aiNode );
+//             }
+
+//             if ( node.HasChildren )
+//             {
+//                 foreach ( var childNode in node.Children )
+//                 {
+//                     aiNode.Children.Add( ConvertNode( model, childNode, aiNode ) );
+//                 }
+//             }
+
+//             return aiNode;
+//         }
+
+//         private static void ConvertNodeProperties( UserPropertyDictionary properties, Ai.Node aiNode )
+//         {
+//             var stringBuilder = new StringBuilder();
+
+//             foreach ( var property in properties.Values )
+//             {
+//                 // Todo: Assign to 3ds max user properties
+//                 stringBuilder.Append( $"{property.ToUserPropertyString()}&cr;&lf;" );
+//             }
+
+//             aiNode.Metadata["UDP3DSMAX"] = new Ai.Metadata.Entry( Ai.MetaDataType.String, stringBuilder.ToString() );
+//         }
+
+//         private void ConvertNodeAttachments( Model model, Node node, Ai.Node aiNode )
+//         {
+//             for ( int i = 0; i < node.Attachments.Count; i++ )
+//             {
+//                 var attachment = node.Attachments[i];
+
+//                 switch ( attachment.Type )
+//                 {
+//                     case NodeAttachmentType.Mesh:
+//                         {
+//                             var mesh = ConvertGeometry( model, node, attachment.GetValue<Mesh>() );
+
+//                             mesh.Name = $"{AssimpConverterCommon.EscapeName(node.Name)}_Attachment{i}_Mesh";
+//                             aiNode.MeshIndices.Add( mAiScene.Meshes.Count );
+//                             mAiScene.Meshes.Add( mesh );
+//                         }
+//                         break;
+
+//                     case NodeAttachmentType.Camera:
+//                         {
+//                             var camera = attachment.GetValue<Camera>();
+//                             mAiScene.Cameras.Add( new Ai.Camera
+//                             {
+//                                 Name          = node.Name,
+//                                 Position      = camera.Position.ToAssimp(),
+//                                 Up            = camera.Up.ToAssimp(),
+//                                 Direction     = -camera.Direction.ToAssimp(),
+//                                 FieldOfview   = MathHelper.DegreesToRadians( camera.FieldOfView ),
+//                                 ClipPlaneNear = camera.ClipPlaneNear,
+//                                 ClipPlaneFar  = camera.ClipPlaneFar,
+//                                 AspectRatio   = camera.AspectRatio
+//                             });
+//                         }
+//                         break;
+
+//                     case NodeAttachmentType.Light:
+//                         {
+//                             var light = attachment.GetValue<Light>();
+//                             mAiScene.Lights.Add( new Ai.Light
+//                             {
+//                                 Name = node.Name,
+//                                 AngleInnerCone = light.AngleInnerCone,
+//                                 AngleOuterCone = light.AngleOuterCone,
+//                                 ColorAmbient = light.AmbientColor.ToAssimpAsColor3D(),
+//                                 ColorDiffuse = light.DiffuseColor.ToAssimpAsColor3D(),
+//                                 ColorSpecular = light.SpecularColor.ToAssimpAsColor3D(),
+//                                 LightType = light.Type == LightType.Point ? Ai.LightSourceType.Point : light.Type == LightType.Spot ? Ai.LightSourceType.Spot : Ai.LightSourceType.Directional,
+//                             });
+//                         }
+//                         break;
+//                     default:
+//                         //throw new NotImplementedException();
+//                         break;
+//                 }
+//             }
+//         }
+
+//         private Ai.Mesh ConvertGeometry( Model model, Node geometryNode, Mesh mesh )
+//         {
+//             var aiMesh = new Ai.Mesh( Ai.PrimitiveType.Triangle );
+
+//             if ( mesh.Flags.HasFlag( GeometryFlags.HasMaterial ) )
+//                 aiMesh.MaterialIndex = mAiScene.Materials.FindIndex( x => x.Name == AssimpConverterCommon.EscapeName(mesh.MaterialName) );
+
+//             if ( mesh.Flags.HasFlag( GeometryFlags.HasTriangles ) )
+//             {
+//                 foreach ( var triangle in mesh.Triangles )
+//                 {
+//                     var aiFace = new Ai.Face();
+//                     aiFace.Indices.Add( ( int )triangle.A );
+//                     aiFace.Indices.Add( ( int )triangle.B );
+//                     aiFace.Indices.Add( ( int )triangle.C );
+//                     aiMesh.Faces.Add( aiFace );
+//                 }
+//             }
+
+//             var vertices = mesh.Vertices;
+//             var normals = mesh.Normals;
+
+//             if ( mesh.VertexWeights != null )
+//                 ( vertices, normals ) = mesh.Transform( geometryNode, model.Nodes.ToList(), model.Bones );
+
+//             if ( mesh.VertexAttributeFlags.HasFlag( VertexAttributeFlags.Position ) )
+//             {
+//                 foreach ( var vertex in vertices )
+//                 {
+//                     aiMesh.Vertices.Add( new Ai.Vector3D( vertex.X, vertex.Y, vertex.Z ) );
+//                 }
+//             }
+
+//             if ( mesh.VertexAttributeFlags.HasFlag( VertexAttributeFlags.Normal ) )
+//             {
+//                 foreach ( var normal in normals )
+//                 {
+//                     aiMesh.Normals.Add( new Ai.Vector3D( normal.X, normal.Y, normal.Z ) );
+//                 }
+//             }
+
+//             if ( mesh.VertexAttributeFlags.HasFlag( VertexAttributeFlags.Tangent ) )
+//             {
+//                 foreach ( var tangent in mesh.Tangents )
+//                 {
+//                     aiMesh.Tangents.Add( new Ai.Vector3D( tangent.X, tangent.Y, tangent.Z ) );
+//                 }
+//             }
+
+//             if ( mesh.VertexAttributeFlags.HasFlag( VertexAttributeFlags.Binormal ) )
+//             {
+//                 foreach ( var binormal in mesh.Binormals )
+//                 {
+//                     aiMesh.BiTangents.Add( new Ai.Vector3D( binormal.X, binormal.Y, binormal.Z ) );
+//                 }
+//             }
+
+//             if ( mesh.VertexAttributeFlags.HasFlag( VertexAttributeFlags.TexCoord0 ) )
+//             {
+//                 foreach ( var vertex in mesh.TexCoordsChannel0 )
+//                 {
+//                     aiMesh.TextureCoordinateChannels[0].Add( new Ai.Vector3D( vertex.X, vertex.Y, 0 ) );
+//                 }
+//             }
+
+//             if ( mesh.VertexAttributeFlags.HasFlag( VertexAttributeFlags.TexCoord1 ) )
+//             {
+//                 foreach ( var vertex in mesh.TexCoordsChannel1 )
+//                 {
+//                     aiMesh.TextureCoordinateChannels[1].Add( new Ai.Vector3D( vertex.X, vertex.Y, 0 ) );
+//                 }
+//             }
+
+//             if ( mesh.VertexAttributeFlags.HasFlag( VertexAttributeFlags.TexCoord2 ) )
+//             {
+//                 foreach ( var vertex in mesh.TexCoordsChannel2 )
+//                 {
+//                     aiMesh.TextureCoordinateChannels[2].Add( new Ai.Vector3D( vertex.X, vertex.Y, 0 ) );
+//                 }
+//             }
+
+//             /* todo: colors
+//             if ( mesh.VertexAttributeFlags.HasFlag( VertexAttributeFlags.Color0 ) )
+//             {
+//                 foreach ( var color in mesh.ColorChannel0 )
+//                 {
+//                     aiMesh.VertexColorChannels[0].Add( new Ai.Color4D( color. ))
+//                 }
+//             }
+//             */
+
+//             if ( mesh.Flags.HasFlag( GeometryFlags.HasVertexWeights ) )
+//             {
+//                 var boneMap = new Dictionary<int, Ai.Bone>();
+
+//                 for ( int i = 0; i < mesh.VertexWeights.Length; i++ )
+//                 {
+//                     var vertexWeight = mesh.VertexWeights[i];
+
+//                     for ( int j = 0; j < 4; j++ )
+//                     {
+//                         var boneWeight = vertexWeight.Weights[j];
+//                         if ( boneWeight == 0f )
+//                             continue;
+
+//                         var boneIndex = vertexWeight.Indices[j];
+//                         var nodeIndex = model.Bones[boneIndex].NodeIndex;
+
+//                         if ( !boneMap.ContainsKey( nodeIndex ) )
+//                         {
+//                             var aiBone = new Ai.Bone();
+//                             var boneNode = model.GetNode( nodeIndex );
+
+//                             aiBone.Name = AssimpConverterCommon.EscapeName( boneNode.Name );
+//                             aiBone.VertexWeights.Add( new Ai.VertexWeight( i, boneWeight ) );
+
+//                             Matrix4x4.Invert( geometryNode.WorldTransform, out Matrix4x4 invGeometryNodeWorldTransform );
+//                             Matrix4x4.Invert( boneNode.WorldTransform * invGeometryNodeWorldTransform, out Matrix4x4 offsetMatrix );
+//                             aiBone.OffsetMatrix = new Ai.Matrix4x4( offsetMatrix.M11, offsetMatrix.M21, offsetMatrix.M31, offsetMatrix.M41,
+//                                                                     offsetMatrix.M12, offsetMatrix.M22, offsetMatrix.M32, offsetMatrix.M42,
+//                                                                     offsetMatrix.M13, offsetMatrix.M23, offsetMatrix.M33, offsetMatrix.M43,
+//                                                                     offsetMatrix.M14, offsetMatrix.M24, offsetMatrix.M34, offsetMatrix.M44 );
+//                             boneMap[nodeIndex] = aiBone;
+//                         }
+//                         else
+//                         {
+//                             boneMap[nodeIndex].VertexWeights.Add( new Ai.VertexWeight( i, boneWeight ) );
+//                         }
+//                     }
+//                 }
+
+//                 aiMesh.Bones.AddRange( boneMap.Values );
+//             }
+
+//             return aiMesh;
+//         }
+//     }
+// }
diff --git a/GFDLibrary/Models/Conversion/Utilities/AssimpExtensions.cs b/GFDLibrary/Models/Conversion/Utilities/AssimpExtensions.cs
index dfb091f..f684571 100644
--- a/GFDLibrary/Models/Conversion/Utilities/AssimpExtensions.cs
+++ b/GFDLibrary/Models/Conversion/Utilities/AssimpExtensions.cs
@@ -1,188 +1,188 @@
-﻿using System.Collections.Generic;
-using System.Diagnostics;
-using System.Linq;
-using System.Numerics;
-using Assimp;
-using GFDLibrary.Graphics;
-using Matrix4x4 = Assimp.Matrix4x4;
-using Quaternion = Assimp.Quaternion;
-
-namespace GFDLibrary.Models.Conversion.Utilities
-{
-    public static class AssimpExtensions
-    {
-        public static Vector3D ToAssimp( this Vector3 value ) => new Vector3D( value.X, value.Y, value.Z );
-
-        public static IEnumerable<Vector3D> ToAssimp( this IEnumerable<Vector3> values ) => values.Select( x => x.ToAssimp() );
-
-        public static Vector3D ToAssimp( this Vector2 value ) => new Vector3D( value.X, value.Y, 0 );
-
-        public static IEnumerable<Vector3D> ToAssimp( this IEnumerable<Vector2> values ) => values.Select( x => x.ToAssimp() );
-
-        public static Color4D ToAssimp( this Vector4 value ) => new Color4D( value.X, value.Y, value.Z, value.W );
-
-        public static Color3D ToAssimpAsColor3D( this Vector4 value ) => new Color3D( value.X, value.Y, value.Z );
-
-        public static IEnumerable<Color4D> ToAssimp( this IEnumerable<Vector4> values ) => values.Select( x => x.ToAssimp() );
-
-        public static Quaternion ToAssimp( this System.Numerics.Quaternion quaternion ) =>
-            new Quaternion( quaternion.W, quaternion.X, quaternion.Y, quaternion.Z );
-
-        public static Matrix4x4 ToAssimp( this System.Numerics.Matrix4x4 matrix )
-        {
-            return new Matrix4x4( matrix.M11, matrix.M21, matrix.M31, matrix.M41,
-                                         matrix.M12, matrix.M22, matrix.M32, matrix.M42,
-                                         matrix.M13, matrix.M23, matrix.M33, matrix.M43,
-                                         matrix.M14, matrix.M24, matrix.M34, matrix.M44 );
-        }
-
-        public static Color4D ToAssimp( this Color value )
-        {
-            return new Color4D( value.R / 255f,
-                                       value.G / 255f,
-                                       value.B / 255f,
-                                       value.A / 255f );
-        }
-
-        public static IEnumerable<Color4D> ToAssimp( this IEnumerable<Color> values ) => values.Select( x => x.ToAssimp() );
-
-        public static void ExportColladaFile( this Scene aiScene, string path )
-        {
-            using ( var aiContext = new AssimpContext() )
-                aiContext.ExportFile( aiScene, path, "collada", PostProcessSteps.JoinIdenticalVertices | PostProcessSteps.FlipUVs | PostProcessSteps.GenerateSmoothNormals );
-        }
-
-        public static Color ToNumerics( this Color4D value )
-        {
-            return new Color( ( byte )( value.R * 255f ),
-                              ( byte )( value.G * 255f ),
-                              ( byte )( value.B * 255f ),
-                              ( byte )( value.A * 255f ) );
-        }
-
-        public static Vector4 ToNumerics( this Color3D value )
-        {
-            return new Vector4( value.R,
-                                value.G,
-                                value.B,
-                                1.0f );
-        }
-
-        public static IEnumerable<Color> ToNumerics( this IEnumerable<Color4D> values ) => values.Select( x => x.ToNumerics() );
-
-        public static System.Numerics.Matrix4x4 ToNumerics( this Matrix4x4 matrix )
-        {
-            return new System.Numerics.Matrix4x4( matrix.A1, matrix.B1, matrix.C1, matrix.D1,
-                                  matrix.A2, matrix.B2, matrix.C2, matrix.D2,
-                                  matrix.A3, matrix.B3, matrix.C3, matrix.D3,
-                                  matrix.A4, matrix.B4, matrix.C4, matrix.D4 );
-        }
-
-        public static Vector3 ToNumerics( this Vector3D value )
-        {
-            return new Vector3( value.X, value.Y, value.Z );
-        }
-
-        public static IEnumerable<Vector3> ToNumerics( this IEnumerable<Vector3D> values ) => values.Select( x => x.ToNumerics() );
-
-        public static Vector2 FromAssimpAsVector2( this Vector3D value )
-        {
-            return new Vector2( value.X, value.Y );
-        }
-
-        public static IEnumerable<Vector2> FromAssimpAsVector2( this IEnumerable<Vector3D> values ) => values.Select( x => x.FromAssimpAsVector2() );
-
-        public static System.Numerics.Quaternion ToNumerics( this Quaternion value )
-        {
-            return new System.Numerics.Quaternion( value.X, value.Y, value.Z, value.W );
-        }
-
-        public static System.Numerics.Matrix4x4 CalculateWorldTransform( this Assimp.Node node )
-        {
-            Matrix4x4 CalculateWorldTransformInternal( Assimp.Node currentNode )
-            {
-                var transform = currentNode.Transform;
-                if ( currentNode.Parent != null )
-                    transform *= CalculateWorldTransformInternal( currentNode.Parent );
-
-                return transform;
-            }
-
-            return ToNumerics( CalculateWorldTransformInternal( node ) );
-        }
-
-        /// <summary>
-        /// Gets the weights assigned to each vertex. This also fixes any missing weights.
-        /// </summary>
-        /// <param name="mesh"></param>
-        /// <returns></returns>
-        public static List<(Assimp.Bone Bone, float Weight)>[] GetVertexWeights( this Assimp.Mesh mesh )
-        {
-            // Map out the vertex weights for each vertex
-            var vertexWeights = new List<(Assimp.Bone, float)>[mesh.VertexCount];
-            var missingVertexWeights = new List<int>();
-            for ( int i = 0; i < mesh.VertexCount; i++ )
-            {
-                var weights = new List<(Assimp.Bone, float)>();
-                foreach ( var bone in mesh.Bones )
-                {
-                    foreach ( var vertexWeight in bone.VertexWeights )
-                    {
-                        if ( vertexWeight.VertexID == i )
-                        {
-                            weights.Add( (bone, vertexWeight.Weight) );
-                        }
-                    }
-                }
-
-                if ( weights.Count == 0 )
-                {
-                    missingVertexWeights.Add( i );
-                    continue;
-                }
-
-                vertexWeights[i] = weights;
-            }
-
-            // Resolve vertices without any weights by finding the closest vertex next to it that does, and taking its weights
-            foreach ( var i in missingVertexWeights )
-            {
-                var position = mesh.Vertices[i];
-                var range = 0.001f;
-                List<(Assimp.Bone, float)> weights = null;
-
-                while ( weights == null )
-                {
-                    for ( var j = 0; j < mesh.Vertices.Count; j++ )
-                    {
-                        if ( missingVertexWeights.Contains( j ) )
-                            continue;
-
-                        // ＤＥＬＴＡ
-                        var otherPosition = mesh.Vertices[j];
-                        var delta = position - otherPosition;
-                        if ( IsWithinRange( delta, range ) )
-                        {
-                            weights = vertexWeights[j];
-                            break;
-                        }
-                    }
-
-                    range *= 2f;
-                }
-
-                vertexWeights[i] = weights;
-            }
-
-            Debug.Assert( vertexWeights.All( x => x != null ) );
-            return vertexWeights;
-        }
-
-        private static bool IsWithinRange( Vector3D position, float range )
-        {
-            return ( position.X < 0 ? position.X >= -range : position.X <= range ) &&
-                   ( position.Y < 0 ? position.Y >= -range : position.Y <= range ) &&
-                   ( position.Z < 0 ? position.Z >= -range : position.Z <= range );
-        }
-    }
-}
+﻿// using System.Collections.Generic;
+// using System.Diagnostics;
+// using System.Linq;
+// using System.Numerics;
+// using Assimp;
+// using GFDLibrary.Graphics;
+// using Matrix4x4 = Assimp.Matrix4x4;
+// using Quaternion = Assimp.Quaternion;
+
+// namespace GFDLibrary.Models.Conversion.Utilities
+// {
+//     public static class AssimpExtensions
+//     {
+//         public static Vector3D ToAssimp( this Vector3 value ) => new Vector3D( value.X, value.Y, value.Z );
+
+//         public static IEnumerable<Vector3D> ToAssimp( this IEnumerable<Vector3> values ) => values.Select( x => x.ToAssimp() );
+
+//         public static Vector3D ToAssimp( this Vector2 value ) => new Vector3D( value.X, value.Y, 0 );
+
+//         public static IEnumerable<Vector3D> ToAssimp( this IEnumerable<Vector2> values ) => values.Select( x => x.ToAssimp() );
+
+//         public static Color4D ToAssimp( this Vector4 value ) => new Color4D( value.X, value.Y, value.Z, value.W );
+
+//         public static Color3D ToAssimpAsColor3D( this Vector4 value ) => new Color3D( value.X, value.Y, value.Z );
+
+//         public static IEnumerable<Color4D> ToAssimp( this IEnumerable<Vector4> values ) => values.Select( x => x.ToAssimp() );
+
+//         public static Quaternion ToAssimp( this System.Numerics.Quaternion quaternion ) =>
+//             new Quaternion( quaternion.W, quaternion.X, quaternion.Y, quaternion.Z );
+
+//         public static Matrix4x4 ToAssimp( this System.Numerics.Matrix4x4 matrix )
+//         {
+//             return new Matrix4x4( matrix.M11, matrix.M21, matrix.M31, matrix.M41,
+//                                          matrix.M12, matrix.M22, matrix.M32, matrix.M42,
+//                                          matrix.M13, matrix.M23, matrix.M33, matrix.M43,
+//                                          matrix.M14, matrix.M24, matrix.M34, matrix.M44 );
+//         }
+
+//         public static Color4D ToAssimp( this Color value )
+//         {
+//             return new Color4D( value.R / 255f,
+//                                        value.G / 255f,
+//                                        value.B / 255f,
+//                                        value.A / 255f );
+//         }
+
+//         public static IEnumerable<Color4D> ToAssimp( this IEnumerable<Color> values ) => values.Select( x => x.ToAssimp() );
+
+//         public static void ExportColladaFile( this Scene aiScene, string path )
+//         {
+//             using ( var aiContext = new AssimpContext() )
+//                 aiContext.ExportFile( aiScene, path, "collada", PostProcessSteps.JoinIdenticalVertices | PostProcessSteps.FlipUVs | PostProcessSteps.GenerateSmoothNormals );
+//         }
+
+//         public static Color ToNumerics( this Color4D value )
+//         {
+//             return new Color( ( byte )( value.R * 255f ),
+//                               ( byte )( value.G * 255f ),
+//                               ( byte )( value.B * 255f ),
+//                               ( byte )( value.A * 255f ) );
+//         }
+
+//         public static Vector4 ToNumerics( this Color3D value )
+//         {
+//             return new Vector4( value.R,
+//                                 value.G,
+//                                 value.B,
+//                                 1.0f );
+//         }
+
+//         public static IEnumerable<Color> ToNumerics( this IEnumerable<Color4D> values ) => values.Select( x => x.ToNumerics() );
+
+//         public static System.Numerics.Matrix4x4 ToNumerics( this Matrix4x4 matrix )
+//         {
+//             return new System.Numerics.Matrix4x4( matrix.A1, matrix.B1, matrix.C1, matrix.D1,
+//                                   matrix.A2, matrix.B2, matrix.C2, matrix.D2,
+//                                   matrix.A3, matrix.B3, matrix.C3, matrix.D3,
+//                                   matrix.A4, matrix.B4, matrix.C4, matrix.D4 );
+//         }
+
+//         public static Vector3 ToNumerics( this Vector3D value )
+//         {
+//             return new Vector3( value.X, value.Y, value.Z );
+//         }
+
+//         public static IEnumerable<Vector3> ToNumerics( this IEnumerable<Vector3D> values ) => values.Select( x => x.ToNumerics() );
+
+//         public static Vector2 FromAssimpAsVector2( this Vector3D value )
+//         {
+//             return new Vector2( value.X, value.Y );
+//         }
+
+//         public static IEnumerable<Vector2> FromAssimpAsVector2( this IEnumerable<Vector3D> values ) => values.Select( x => x.FromAssimpAsVector2() );
+
+//         public static System.Numerics.Quaternion ToNumerics( this Quaternion value )
+//         {
+//             return new System.Numerics.Quaternion( value.X, value.Y, value.Z, value.W );
+//         }
+
+//         public static System.Numerics.Matrix4x4 CalculateWorldTransform( this Assimp.Node node )
+//         {
+//             Matrix4x4 CalculateWorldTransformInternal( Assimp.Node currentNode )
+//             {
+//                 var transform = currentNode.Transform;
+//                 if ( currentNode.Parent != null )
+//                     transform *= CalculateWorldTransformInternal( currentNode.Parent );
+
+//                 return transform;
+//             }
+
+//             return ToNumerics( CalculateWorldTransformInternal( node ) );
+//         }
+
+//         /// <summary>
+//         /// Gets the weights assigned to each vertex. This also fixes any missing weights.
+//         /// </summary>
+//         /// <param name="mesh"></param>
+//         /// <returns></returns>
+//         public static List<(Assimp.Bone Bone, float Weight)>[] GetVertexWeights( this Assimp.Mesh mesh )
+//         {
+//             // Map out the vertex weights for each vertex
+//             var vertexWeights = new List<(Assimp.Bone, float)>[mesh.VertexCount];
+//             var missingVertexWeights = new List<int>();
+//             for ( int i = 0; i < mesh.VertexCount; i++ )
+//             {
+//                 var weights = new List<(Assimp.Bone, float)>();
+//                 foreach ( var bone in mesh.Bones )
+//                 {
+//                     foreach ( var vertexWeight in bone.VertexWeights )
+//                     {
+//                         if ( vertexWeight.VertexID == i )
+//                         {
+//                             weights.Add( (bone, vertexWeight.Weight) );
+//                         }
+//                     }
+//                 }
+
+//                 if ( weights.Count == 0 )
+//                 {
+//                     missingVertexWeights.Add( i );
+//                     continue;
+//                 }
+
+//                 vertexWeights[i] = weights;
+//             }
+
+//             // Resolve vertices without any weights by finding the closest vertex next to it that does, and taking its weights
+//             foreach ( var i in missingVertexWeights )
+//             {
+//                 var position = mesh.Vertices[i];
+//                 var range = 0.001f;
+//                 List<(Assimp.Bone, float)> weights = null;
+
+//                 while ( weights == null )
+//                 {
+//                     for ( var j = 0; j < mesh.Vertices.Count; j++ )
+//                     {
+//                         if ( missingVertexWeights.Contains( j ) )
+//                             continue;
+
+//                         // ＤＥＬＴＡ
+//                         var otherPosition = mesh.Vertices[j];
+//                         var delta = position - otherPosition;
+//                         if ( IsWithinRange( delta, range ) )
+//                         {
+//                             weights = vertexWeights[j];
+//                             break;
+//                         }
+//                     }
+
+//                     range *= 2f;
+//                 }
+
+//                 vertexWeights[i] = weights;
+//             }
+
+//             Debug.Assert( vertexWeights.All( x => x != null ) );
+//             return vertexWeights;
+//         }
+
+//         private static bool IsWithinRange( Vector3D position, float range )
+//         {
+//             return ( position.X < 0 ? position.X >= -range : position.X <= range ) &&
+//                    ( position.Y < 0 ? position.Y >= -range : position.Y <= range ) &&
+//                    ( position.Z < 0 ? position.Z >= -range : position.Z <= range );
+//         }
+//     }
+// }
diff --git a/GFDLibrary/Models/Conversion/Utilities/AssimpHelper.cs b/GFDLibrary/Models/Conversion/Utilities/AssimpHelper.cs
index ecf38bd..4537097 100644
--- a/GFDLibrary/Models/Conversion/Utilities/AssimpHelper.cs
+++ b/GFDLibrary/Models/Conversion/Utilities/AssimpHelper.cs
@@ -1,418 +1,418 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.Linq;
-using Assimp;
-
-namespace GFDLibrary.Models.Conversion.Utilities
-{
-    /// <summary>
-    /// Provides various useful utilities for working with Assimp .
-    /// </summary>
-    public static class AssimpHelper
-    {
-        /// <summary>
-        /// Creates a default, empty scene with a root node.
-        /// </summary>
-        /// <returns></returns>
-        public static Scene CreateDefaultScene()
-        {
-            var aiScene = new Scene { RootNode = new Assimp.Node( "RootNode" ) };
-            return aiScene;
-        }
-
-        /// <summary>
-        /// Imports an Assimp scene with default settings.
-        /// </summary>
-        /// <param name="path"></param>
-        /// <returns></returns>
-        public static Scene ImportScene( string path )
-        {
-            using ( var aiContext = new AssimpContext() )
-            {
-                aiContext.SetConfig( new Assimp.Configs.VertexBoneWeightLimitConfig( 4 ) );
-                aiContext.SetConfig( new Assimp.Configs.FBXPreservePivotsConfig( false ) );
-                return aiContext.ImportFile( path,
-                                             PostProcessSteps.FindDegenerates | PostProcessSteps.FindInvalidData |
-                                             PostProcessSteps.FlipUVs | PostProcessSteps.ImproveCacheLocality |
-                                             PostProcessSteps.JoinIdenticalVertices | PostProcessSteps.LimitBoneWeights |
-                                             PostProcessSteps.SplitByBoneCount | PostProcessSteps.Triangulate |
-                                             PostProcessSteps.ValidateDataStructure | PostProcessSteps.GenerateUVCoords |
-                                             PostProcessSteps.GenerateSmoothNormals );
-            }
-        }
-
-        /// <summary>
-        /// Determines the best target scene node for the mesh.
-        /// </summary>
-        /// <typeparam name="T"></typeparam>
-        /// <param name="aiMesh"></param>
-        /// <param name="aiNode"></param>
-        /// <param name="nodeSearchFunc"></param>
-        /// <param name="fallback"></param>
-        /// <returns></returns>
-        public static T DetermineBestTargetNode<T>( Assimp.Mesh aiMesh, Assimp.Node aiNode, Func<string,T> nodeSearchFunc, T fallback )
-        {
-            if ( aiMesh.BoneCount > 1 )
-            {
-                // Select node to which the mesh is weighted most
-                var boneWeightCoverage = CalculateBoneWeightCoverage( aiMesh );
-                var maxCoverage        = boneWeightCoverage.Max( x => x.Coverage );
-                var bestTargetBone     = boneWeightCoverage.First( x => x.Coverage == maxCoverage ).Bone;
-                return nodeSearchFunc( bestTargetBone.Name );
-            }
-            else if ( aiMesh.BoneCount == 1 )
-            {
-                // Use our only bone as the target node
-                return nodeSearchFunc( aiMesh.Bones[ 0 ].Name );
-            }
-            else
-            {
-                // Try to find a parent of the mesh's ainode that exists within the existing hierarchy
-                var aiNodeParent = aiNode.Parent;
-                while ( aiNodeParent != null )
-                {
-                    var nodeParent = nodeSearchFunc( aiNodeParent.Name );
-                    if ( nodeParent != null )
-                        return nodeParent;
-
-                    aiNodeParent = aiNodeParent.Parent;
-                }
-
-                // Return fallback
-                return fallback;
-            }
-        }
-
-        public static Assimp.Node GetHierarchyRootNode( Assimp.Node aiSceneRootNode )
-        {
-            // Pretty naiive for now.
-            return aiSceneRootNode.Children.Single( x => !x.HasMeshes );
-        }
-
-        public static List<Assimp.Node> GetMeshNodes( Assimp.Node aiSceneRootNode )
-        {
-            var meshNodes = new List<Assimp.Node>();
-
-            void FindMeshNodesRecursively( Assimp.Node aiParentNode )
-            {
-                foreach ( var aiNode in aiParentNode.Children )
-                {
-                    if ( aiNode.HasMeshes )
-                        meshNodes.Add( aiNode );
-                    else
-                        FindMeshNodesRecursively( aiNode );
-                }
-            }
-
-            FindMeshNodesRecursively( aiSceneRootNode );
-
-            return meshNodes;
-        }
-
-        /// <summary>
-        /// Calculate the weight coverage (in percent) of each bone in the mesh.
-        /// </summary>
-        /// <param name="aiMesh"></param>
-        /// <returns></returns>
-        public static List<(float Coverage, Assimp.Bone Bone)> CalculateBoneWeightCoverage( Assimp.Mesh aiMesh )
-        {
-            var boneScores = new List<(float Coverage, Assimp.Bone Bone)>();
-
-            foreach ( var bone in aiMesh.Bones )
-            {
-                float weightTotal = 0;
-                foreach ( var vertexWeight in bone.VertexWeights )
-                    weightTotal += vertexWeight.Weight;
-
-                float weightCoverage = ( weightTotal / aiMesh.VertexCount );
-                boneScores.Add( (weightCoverage, bone) );
-            }
-
-            return boneScores;
-        }
-
-        /// <summary>
-        /// Splits the mesh into submeshes that use <paramref name="maxBoneCount"/> or less bones.
-        /// </summary>
-        /// <param name="scene"></param>
-        /// <param name="mesh"></param>
-        /// <param name="maxBoneCount"></param>
-        /// <returns></returns>
-        public static List<Assimp.Mesh> SplitMeshByBoneCount( Assimp.Mesh mesh, int maxBoneCount )
-        {
-            if ( mesh.BoneCount <= maxBoneCount )
-                return new List<Assimp.Mesh> { mesh };
-
-            var vertexWeights = mesh.GetVertexWeights();
-            var subMeshes = new List<Assimp.Mesh>();
-            var remainingFaces = mesh.Faces.ToList();
-
-            while ( remainingFaces.Count > 0 )
-            {
-                var usedBones = new HashSet<Assimp.Bone>();
-                var faces = new List<Face>();
-
-                // Get faces that fit inside the new mesh
-                foreach ( var face in remainingFaces )
-                {
-                    var faceUsedBones = face.Indices.SelectMany( y => vertexWeights[y].Select( z => z.Item1 ) ).ToList();
-                    var faceUniqueUsedBoneCount = faceUsedBones.Count( x => !usedBones.Contains( x ) );
-                    if ( ( usedBones.Count + faceUniqueUsedBoneCount ) > maxBoneCount )
-                    {
-                        // Skip
-                        continue;
-                    }
-
-                    // It does fit ＼(^o^)／
-                    faces.Add( face );
-                    foreach ( var node in faceUsedBones )
-                        usedBones.Add( node );
-
-                    Debug.Assert( usedBones.Count <= maxBoneCount );
-                }
-
-                if ( faces.Count == 0 )
-                {
-                    if ( remainingFaces.All( x => x.Indices.SelectMany( y => vertexWeights[y].Select( z => z.Item1 ) ).Count() > maxBoneCount ) )
-                    {
-                        // Need to reduce weights per face
-                        Debug.Assert( false ); // would need averaging..
-                    }
-                }
-
-                // Remove the faces we claimed from the pool
-                foreach ( var face in faces )
-                    remainingFaces.Remove( face );
-
-                // Build submesh
-                var subMesh = new Assimp.Mesh()
-                {
-                    MaterialIndex = mesh.MaterialIndex,
-                    //MorphMethod = mesh.MorphMethod,
-                    Name = mesh.Name + $"_submesh{subMeshes.Count}",
-                    PrimitiveType = mesh.PrimitiveType,
-                };
-                var vertexCache = new List<Vertex>();
-                foreach ( var face in faces )
-                {
-                    var newFace = new Face();
-
-                    foreach ( var index in face.Indices )
-                    {
-                        var cacheIndex = FindVertexCacheIndex( mesh, index, vertexWeights, vertexCache, out var vertex );
-                        if ( cacheIndex == -1 )
-                        {
-                            // This vertex is new
-#if DEBUG
-                            for ( int i = 0; i < vertex.Weights.Count; i++ )
-                                Debug.Assert( usedBones.Contains( vertex.Weights[i].Item1 ) );
-#endif
-                            cacheIndex = vertexCache.Count;
-                            vertexCache.Add( vertex );
-                        }
-
-                        newFace.Indices.Add( cacheIndex );
-                    }
-
-                    subMesh.Faces.Add( newFace );
-                }
-
-                PopulateSubMeshVertexData( mesh, subMesh, vertexCache );
-
-#if DEBUG
-                CheckIfAllVerticesHaveWeights( subMesh );
-#endif
-
-                subMeshes.Add( subMesh );
-            }
-
-            return subMeshes;
-        }
-
-        /// <summary>
-        /// Splits the mesh into submeshes that use <paramref name="maxVertexCount"/> or less vertices.
-        /// </summary>
-        /// <param name="mesh"></param>
-        /// <param name="maxVertexCount"></param>
-        /// <returns></returns>
-        public static List<Assimp.Mesh> SplitMeshByVertexCount( Assimp.Mesh mesh, int maxVertexCount )
-        {
-            if ( mesh.VertexCount <= maxVertexCount )
-                return new List<Assimp.Mesh> { mesh };
-
-            var vertexWeights = mesh.HasBones ? mesh.GetVertexWeights() : null;
-            var remainingFaces = mesh.Faces.ToList();
-            var subMeshes = new List<Assimp.Mesh>();
-
-            while ( remainingFaces.Count > 0 )
-            {
-                // Build submesh
-                var subMesh = new Assimp.Mesh()
-                {
-                    MaterialIndex = mesh.MaterialIndex,
-                    //MorphMethod = mesh.MorphMethod,
-                    Name = mesh.Name + $"_submesh{subMeshes.Count}",
-                    PrimitiveType = mesh.PrimitiveType,
-                };
-
-                var processedFaces = new List<Face>();
-                var vertexCache = new List<Vertex>();
-
-                // Get faces that fit inside the new mesh
-                foreach ( var face in remainingFaces )
-                {
-                    var newVertices = new List<Vertex>();
-                    var newFace     = new Face();
-                    foreach ( var i in face.Indices )
-                    {
-                        var cacheIndex = FindVertexCacheIndex( mesh, i, vertexWeights, vertexCache, out var vertex );
-                        if ( cacheIndex == -1 )
-                        {
-                            // This vertex is new
-                            cacheIndex = vertexCache.Count + newVertices.Count;
-                            newVertices.Add( vertex );
-                        }
-
-                        newFace.Indices.Add( cacheIndex );
-                    }
-
-                    if ( vertexCache.Count + newVertices.Count > maxVertexCount )
-                    {
-                        // Doesn't fit
-                        continue;
-                    }
-
-                    // It does fit ＼(^o^)／
-                    subMesh.Faces.Add( newFace );
-                    processedFaces.Add( face );
-                    foreach ( var vertex in newVertices )
-                        vertexCache.Add( vertex );
-
-                    Debug.Assert( vertexCache.Count <= maxVertexCount );
-
-                    if ( vertexCache.Count == maxVertexCount )
-                    {
-                        // We're done for sure
-                        break;
-                    }
-                }
-
-                // Remove the faces we processed from the remaining list
-                foreach ( var face in processedFaces )
-                    remainingFaces.Remove( face );
-
-                PopulateSubMeshVertexData( mesh, subMesh, vertexCache );
-
-#if DEBUG
-                CheckIfAllVerticesHaveWeights( subMesh );
-#endif
-
-                subMeshes.Add( subMesh );
-            }
-
-            return subMeshes;
-        }
-
-        private static int FindVertexCacheIndex(Assimp.Mesh mesh, int i, List<(Assimp.Bone,float)>[] vertexWeights, List<Vertex> vertexCache, out Vertex vertex )
-        {
-            var position  = mesh.HasVertices ? mesh.Vertices[i] : new Vector3D();
-            var normal    = mesh.HasNormals ? mesh.Normals[i] : new Vector3D();
-            var tangent   = mesh.HasTangentBasis ? mesh.Tangents[i] : new Vector3D();
-            var texCoord  = mesh.HasTextureCoords( 0 ) ? mesh.TextureCoordinateChannels[0][i] : new Vector3D();
-            var texCoord2 = mesh.HasTextureCoords( 1 ) ? mesh.TextureCoordinateChannels[1][i] : new Vector3D();
-            var color     = mesh.HasVertexColors( 0 ) ? mesh.VertexColorChannels[0][i] : new Color4D();
-            var weights   = mesh.HasBones ? vertexWeights[i] : new List<(Assimp.Bone, float)>();
-            var cacheIndex = vertexCache.FindIndex( y => y.Position == position && y.Normal == normal && y.Tangent == tangent && y.TexCoord == texCoord &&
-                                                         y.TexCoord2 == texCoord2 && y.Color == color &&
-                                                         y.Weights.SequenceEqual( weights ) );
-
-            vertex = new Vertex( position, normal, tangent, texCoord, texCoord2, color, weights );
-            return cacheIndex;
-        }
-
-        private static void PopulateSubMeshVertexData( Assimp.Mesh mesh, Assimp.Mesh subMesh, List<Vertex> vertexCache )
-        {
-            var vertexIndex = 0;
-            foreach ( var vertex in vertexCache )
-            {
-                // Split the vertex data from the cache
-                if ( mesh.HasVertices )
-                    subMesh.Vertices.Add( vertex.Position );
-
-                if ( mesh.HasNormals )
-                    subMesh.Normals.Add( vertex.Normal );
+﻿// using System;
+// using System.Collections.Generic;
+// using System.Diagnostics;
+// using System.Linq;
+// using Assimp;
+
+// namespace GFDLibrary.Models.Conversion.Utilities
+// {
+//     /// <summary>
+//     /// Provides various useful utilities for working with Assimp .
+//     /// </summary>
+//     public static class AssimpHelper
+//     {
+//         /// <summary>
+//         /// Creates a default, empty scene with a root node.
+//         /// </summary>
+//         /// <returns></returns>
+//         public static Scene CreateDefaultScene()
+//         {
+//             var aiScene = new Scene { RootNode = new Assimp.Node( "RootNode" ) };
+//             return aiScene;
+//         }
+
+//         /// <summary>
+//         /// Imports an Assimp scene with default settings.
+//         /// </summary>
+//         /// <param name="path"></param>
+//         /// <returns></returns>
+//         public static Scene ImportScene( string path )
+//         {
+//             using ( var aiContext = new AssimpContext() )
+//             {
+//                 aiContext.SetConfig( new Assimp.Configs.VertexBoneWeightLimitConfig( 4 ) );
+//                 aiContext.SetConfig( new Assimp.Configs.FBXPreservePivotsConfig( false ) );
+//                 return aiContext.ImportFile( path,
+//                                              PostProcessSteps.FindDegenerates | PostProcessSteps.FindInvalidData |
+//                                              PostProcessSteps.FlipUVs | PostProcessSteps.ImproveCacheLocality |
+//                                              PostProcessSteps.JoinIdenticalVertices | PostProcessSteps.LimitBoneWeights |
+//                                              PostProcessSteps.SplitByBoneCount | PostProcessSteps.Triangulate |
+//                                              PostProcessSteps.ValidateDataStructure | PostProcessSteps.GenerateUVCoords |
+//                                              PostProcessSteps.GenerateSmoothNormals );
+//             }
+//         }
+
+//         /// <summary>
+//         /// Determines the best target scene node for the mesh.
+//         /// </summary>
+//         /// <typeparam name="T"></typeparam>
+//         /// <param name="aiMesh"></param>
+//         /// <param name="aiNode"></param>
+//         /// <param name="nodeSearchFunc"></param>
+//         /// <param name="fallback"></param>
+//         /// <returns></returns>
+//         public static T DetermineBestTargetNode<T>( Assimp.Mesh aiMesh, Assimp.Node aiNode, Func<string,T> nodeSearchFunc, T fallback )
+//         {
+//             if ( aiMesh.BoneCount > 1 )
+//             {
+//                 // Select node to which the mesh is weighted most
+//                 var boneWeightCoverage = CalculateBoneWeightCoverage( aiMesh );
+//                 var maxCoverage        = boneWeightCoverage.Max( x => x.Coverage );
+//                 var bestTargetBone     = boneWeightCoverage.First( x => x.Coverage == maxCoverage ).Bone;
+//                 return nodeSearchFunc( bestTargetBone.Name );
+//             }
+//             else if ( aiMesh.BoneCount == 1 )
+//             {
+//                 // Use our only bone as the target node
+//                 return nodeSearchFunc( aiMesh.Bones[ 0 ].Name );
+//             }
+//             else
+//             {
+//                 // Try to find a parent of the mesh's ainode that exists within the existing hierarchy
+//                 var aiNodeParent = aiNode.Parent;
+//                 while ( aiNodeParent != null )
+//                 {
+//                     var nodeParent = nodeSearchFunc( aiNodeParent.Name );
+//                     if ( nodeParent != null )
+//                         return nodeParent;
+
+//                     aiNodeParent = aiNodeParent.Parent;
+//                 }
+
+//                 // Return fallback
+//                 return fallback;
+//             }
+//         }
+
+//         public static Assimp.Node GetHierarchyRootNode( Assimp.Node aiSceneRootNode )
+//         {
+//             // Pretty naiive for now.
+//             return aiSceneRootNode.Children.Single( x => !x.HasMeshes );
+//         }
+
+//         public static List<Assimp.Node> GetMeshNodes( Assimp.Node aiSceneRootNode )
+//         {
+//             var meshNodes = new List<Assimp.Node>();
+
+//             void FindMeshNodesRecursively( Assimp.Node aiParentNode )
+//             {
+//                 foreach ( var aiNode in aiParentNode.Children )
+//                 {
+//                     if ( aiNode.HasMeshes )
+//                         meshNodes.Add( aiNode );
+//                     else
+//                         FindMeshNodesRecursively( aiNode );
+//                 }
+//             }
+
+//             FindMeshNodesRecursively( aiSceneRootNode );
+
+//             return meshNodes;
+//         }
+
+//         /// <summary>
+//         /// Calculate the weight coverage (in percent) of each bone in the mesh.
+//         /// </summary>
+//         /// <param name="aiMesh"></param>
+//         /// <returns></returns>
+//         public static List<(float Coverage, Assimp.Bone Bone)> CalculateBoneWeightCoverage( Assimp.Mesh aiMesh )
+//         {
+//             var boneScores = new List<(float Coverage, Assimp.Bone Bone)>();
+
+//             foreach ( var bone in aiMesh.Bones )
+//             {
+//                 float weightTotal = 0;
+//                 foreach ( var vertexWeight in bone.VertexWeights )
+//                     weightTotal += vertexWeight.Weight;
+
+//                 float weightCoverage = ( weightTotal / aiMesh.VertexCount );
+//                 boneScores.Add( (weightCoverage, bone) );
+//             }
+
+//             return boneScores;
+//         }
+
+//         /// <summary>
+//         /// Splits the mesh into submeshes that use <paramref name="maxBoneCount"/> or less bones.
+//         /// </summary>
+//         /// <param name="scene"></param>
+//         /// <param name="mesh"></param>
+//         /// <param name="maxBoneCount"></param>
+//         /// <returns></returns>
+//         public static List<Assimp.Mesh> SplitMeshByBoneCount( Assimp.Mesh mesh, int maxBoneCount )
+//         {
+//             if ( mesh.BoneCount <= maxBoneCount )
+//                 return new List<Assimp.Mesh> { mesh };
+
+//             var vertexWeights = mesh.GetVertexWeights();
+//             var subMeshes = new List<Assimp.Mesh>();
+//             var remainingFaces = mesh.Faces.ToList();
+
+//             while ( remainingFaces.Count > 0 )
+//             {
+//                 var usedBones = new HashSet<Assimp.Bone>();
+//                 var faces = new List<Face>();
+
+//                 // Get faces that fit inside the new mesh
+//                 foreach ( var face in remainingFaces )
+//                 {
+//                     var faceUsedBones = face.Indices.SelectMany( y => vertexWeights[y].Select( z => z.Item1 ) ).ToList();
+//                     var faceUniqueUsedBoneCount = faceUsedBones.Count( x => !usedBones.Contains( x ) );
+//                     if ( ( usedBones.Count + faceUniqueUsedBoneCount ) > maxBoneCount )
+//                     {
+//                         // Skip
+//                         continue;
+//                     }
+
+//                     // It does fit ＼(^o^)／
+//                     faces.Add( face );
+//                     foreach ( var node in faceUsedBones )
+//                         usedBones.Add( node );
+
+//                     Debug.Assert( usedBones.Count <= maxBoneCount );
+//                 }
+
+//                 if ( faces.Count == 0 )
+//                 {
+//                     if ( remainingFaces.All( x => x.Indices.SelectMany( y => vertexWeights[y].Select( z => z.Item1 ) ).Count() > maxBoneCount ) )
+//                     {
+//                         // Need to reduce weights per face
+//                         Debug.Assert( false ); // would need averaging..
+//                     }
+//                 }
+
+//                 // Remove the faces we claimed from the pool
+//                 foreach ( var face in faces )
+//                     remainingFaces.Remove( face );
+
+//                 // Build submesh
+//                 var subMesh = new Assimp.Mesh()
+//                 {
+//                     MaterialIndex = mesh.MaterialIndex,
+//                     //MorphMethod = mesh.MorphMethod,
+//                     Name = mesh.Name + $"_submesh{subMeshes.Count}",
+//                     PrimitiveType = mesh.PrimitiveType,
+//                 };
+//                 var vertexCache = new List<Vertex>();
+//                 foreach ( var face in faces )
+//                 {
+//                     var newFace = new Face();
+
+//                     foreach ( var index in face.Indices )
+//                     {
+//                         var cacheIndex = FindVertexCacheIndex( mesh, index, vertexWeights, vertexCache, out var vertex );
+//                         if ( cacheIndex == -1 )
+//                         {
+//                             // This vertex is new
+// #if DEBUG
+//                             for ( int i = 0; i < vertex.Weights.Count; i++ )
+//                                 Debug.Assert( usedBones.Contains( vertex.Weights[i].Item1 ) );
+// #endif
+//                             cacheIndex = vertexCache.Count;
+//                             vertexCache.Add( vertex );
+//                         }
+
+//                         newFace.Indices.Add( cacheIndex );
+//                     }
+
+//                     subMesh.Faces.Add( newFace );
+//                 }
+
+//                 PopulateSubMeshVertexData( mesh, subMesh, vertexCache );
+
+// #if DEBUG
+//                 CheckIfAllVerticesHaveWeights( subMesh );
+// #endif
+
+//                 subMeshes.Add( subMesh );
+//             }
+
+//             return subMeshes;
+//         }
+
+//         /// <summary>
+//         /// Splits the mesh into submeshes that use <paramref name="maxVertexCount"/> or less vertices.
+//         /// </summary>
+//         /// <param name="mesh"></param>
+//         /// <param name="maxVertexCount"></param>
+//         /// <returns></returns>
+//         public static List<Assimp.Mesh> SplitMeshByVertexCount( Assimp.Mesh mesh, int maxVertexCount )
+//         {
+//             if ( mesh.VertexCount <= maxVertexCount )
+//                 return new List<Assimp.Mesh> { mesh };
+
+//             var vertexWeights = mesh.HasBones ? mesh.GetVertexWeights() : null;
+//             var remainingFaces = mesh.Faces.ToList();
+//             var subMeshes = new List<Assimp.Mesh>();
+
+//             while ( remainingFaces.Count > 0 )
+//             {
+//                 // Build submesh
+//                 var subMesh = new Assimp.Mesh()
+//                 {
+//                     MaterialIndex = mesh.MaterialIndex,
+//                     //MorphMethod = mesh.MorphMethod,
+//                     Name = mesh.Name + $"_submesh{subMeshes.Count}",
+//                     PrimitiveType = mesh.PrimitiveType,
+//                 };
+
+//                 var processedFaces = new List<Face>();
+//                 var vertexCache = new List<Vertex>();
+
+//                 // Get faces that fit inside the new mesh
+//                 foreach ( var face in remainingFaces )
+//                 {
+//                     var newVertices = new List<Vertex>();
+//                     var newFace     = new Face();
+//                     foreach ( var i in face.Indices )
+//                     {
+//                         var cacheIndex = FindVertexCacheIndex( mesh, i, vertexWeights, vertexCache, out var vertex );
+//                         if ( cacheIndex == -1 )
+//                         {
+//                             // This vertex is new
+//                             cacheIndex = vertexCache.Count + newVertices.Count;
+//                             newVertices.Add( vertex );
+//                         }
+
+//                         newFace.Indices.Add( cacheIndex );
+//                     }
+
+//                     if ( vertexCache.Count + newVertices.Count > maxVertexCount )
+//                     {
+//                         // Doesn't fit
+//                         continue;
+//                     }
+
+//                     // It does fit ＼(^o^)／
+//                     subMesh.Faces.Add( newFace );
+//                     processedFaces.Add( face );
+//                     foreach ( var vertex in newVertices )
+//                         vertexCache.Add( vertex );
+
+//                     Debug.Assert( vertexCache.Count <= maxVertexCount );
+
+//                     if ( vertexCache.Count == maxVertexCount )
+//                     {
+//                         // We're done for sure
+//                         break;
+//                     }
+//                 }
+
+//                 // Remove the faces we processed from the remaining list
+//                 foreach ( var face in processedFaces )
+//                     remainingFaces.Remove( face );
+
+//                 PopulateSubMeshVertexData( mesh, subMesh, vertexCache );
+
+// #if DEBUG
+//                 CheckIfAllVerticesHaveWeights( subMesh );
+// #endif
+
+//                 subMeshes.Add( subMesh );
+//             }
+
+//             return subMeshes;
+//         }
+
+//         private static int FindVertexCacheIndex(Assimp.Mesh mesh, int i, List<(Assimp.Bone,float)>[] vertexWeights, List<Vertex> vertexCache, out Vertex vertex )
+//         {
+//             var position  = mesh.HasVertices ? mesh.Vertices[i] : new Vector3D();
+//             var normal    = mesh.HasNormals ? mesh.Normals[i] : new Vector3D();
+//             var tangent   = mesh.HasTangentBasis ? mesh.Tangents[i] : new Vector3D();
+//             var texCoord  = mesh.HasTextureCoords( 0 ) ? mesh.TextureCoordinateChannels[0][i] : new Vector3D();
+//             var texCoord2 = mesh.HasTextureCoords( 1 ) ? mesh.TextureCoordinateChannels[1][i] : new Vector3D();
+//             var color     = mesh.HasVertexColors( 0 ) ? mesh.VertexColorChannels[0][i] : new Color4D();
+//             var weights   = mesh.HasBones ? vertexWeights[i] : new List<(Assimp.Bone, float)>();
+//             var cacheIndex = vertexCache.FindIndex( y => y.Position == position && y.Normal == normal && y.Tangent == tangent && y.TexCoord == texCoord &&
+//                                                          y.TexCoord2 == texCoord2 && y.Color == color &&
+//                                                          y.Weights.SequenceEqual( weights ) );
+
+//             vertex = new Vertex( position, normal, tangent, texCoord, texCoord2, color, weights );
+//             return cacheIndex;
+//         }
+
+//         private static void PopulateSubMeshVertexData( Assimp.Mesh mesh, Assimp.Mesh subMesh, List<Vertex> vertexCache )
+//         {
+//             var vertexIndex = 0;
+//             foreach ( var vertex in vertexCache )
+//             {
+//                 // Split the vertex data from the cache
+//                 if ( mesh.HasVertices )
+//                     subMesh.Vertices.Add( vertex.Position );
+
+//                 if ( mesh.HasNormals )
+//                     subMesh.Normals.Add( vertex.Normal );
                 
-                if ( mesh.HasTangentBasis )
-                    subMesh.Tangents.Add( vertex.Tangent );
-
-                if ( mesh.HasTextureCoords( 0 ) )
-                    subMesh.TextureCoordinateChannels[0].Add( vertex.TexCoord );
-
-                if ( mesh.HasTextureCoords( 1 ) )
-                    subMesh.TextureCoordinateChannels[1].Add( vertex.TexCoord2 );
-
-                if ( mesh.HasVertexColors( 0 ) )
-                    subMesh.VertexColorChannels[0].Add( vertex.Color );
-
-                if ( mesh.HasBones )
-                {
-                    foreach ( var boneWeight in vertex.Weights )
-                    {
-                        var subMeshBone = subMesh.Bones.FirstOrDefault( x => x.Name == boneWeight.Bone.Name );
-                        if ( subMeshBone == null )
-                        {
-                            subMeshBone = new Assimp.Bone
-                            {
-                                Name = boneWeight.Bone.Name,
-                                OffsetMatrix = boneWeight.Bone.OffsetMatrix
-                            };
-                            subMesh.Bones.Add( subMeshBone );
-                        }
-
-                        subMeshBone.VertexWeights.Add( new Assimp.VertexWeight( vertexIndex, boneWeight.Weight ) );
-                    }
-                }
-
-                ++vertexIndex;
-            }
-        }
-
-        private static void CheckIfAllVerticesHaveWeights( Assimp.Mesh subMesh )
-        {
-            if ( subMesh.HasBones )
-            {
-                var vertexIndices = Enumerable.Range( 0, subMesh.VertexCount ).ToList();
-                foreach ( var bone in subMesh.Bones )
-                {
-                    foreach ( var vertexWeight in bone.VertexWeights )
-                        vertexIndices.Remove( vertexWeight.VertexID );
-                }
-
-                Debug.Assert( vertexIndices.Count == 0 );
-            }
-        }
-
-        private struct Vertex
-        {
-            public readonly Vector3D Position;
-            public readonly Vector3D Normal;
-            public readonly Vector3D Tangent;
-            public readonly Vector3D TexCoord;
-            public readonly Vector3D TexCoord2;
-            public readonly Color4D Color;
-            public readonly List<(Assimp.Bone Bone, float Weight)> Weights;
-
-            public Vertex( Vector3D position, Vector3D normal, Vector3D tangent, Vector3D texCoord, Vector3D texCoord2, Color4D color, List<(Assimp.Bone, float)> weights )
-            {
-                Position = position;
-                Normal = normal;
-                Tangent = tangent;
-                TexCoord = texCoord;
-                TexCoord2 = texCoord2;
-                Color = color;
-                Weights = weights;
-            }
-        }
-    }
-}
+//                 if ( mesh.HasTangentBasis )
+//                     subMesh.Tangents.Add( vertex.Tangent );
+
+//                 if ( mesh.HasTextureCoords( 0 ) )
+//                     subMesh.TextureCoordinateChannels[0].Add( vertex.TexCoord );
+
+//                 if ( mesh.HasTextureCoords( 1 ) )
+//                     subMesh.TextureCoordinateChannels[1].Add( vertex.TexCoord2 );
+
+//                 if ( mesh.HasVertexColors( 0 ) )
+//                     subMesh.VertexColorChannels[0].Add( vertex.Color );
+
+//                 if ( mesh.HasBones )
+//                 {
+//                     foreach ( var boneWeight in vertex.Weights )
+//                     {
+//                         var subMeshBone = subMesh.Bones.FirstOrDefault( x => x.Name == boneWeight.Bone.Name );
+//                         if ( subMeshBone == null )
+//                         {
+//                             subMeshBone = new Assimp.Bone
+//                             {
+//                                 Name = boneWeight.Bone.Name,
+//                                 OffsetMatrix = boneWeight.Bone.OffsetMatrix
+//                             };
+//                             subMesh.Bones.Add( subMeshBone );
+//                         }
+
+//                         subMeshBone.VertexWeights.Add( new Assimp.VertexWeight( vertexIndex, boneWeight.Weight ) );
+//                     }
+//                 }
+
+//                 ++vertexIndex;
+//             }
+//         }
+
+//         private static void CheckIfAllVerticesHaveWeights( Assimp.Mesh subMesh )
+//         {
+//             if ( subMesh.HasBones )
+//             {
+//                 var vertexIndices = Enumerable.Range( 0, subMesh.VertexCount ).ToList();
+//                 foreach ( var bone in subMesh.Bones )
+//                 {
+//                     foreach ( var vertexWeight in bone.VertexWeights )
+//                         vertexIndices.Remove( vertexWeight.VertexID );
+//                 }
+
+//                 Debug.Assert( vertexIndices.Count == 0 );
+//             }
+//         }
+
+//         private struct Vertex
+//         {
+//             public readonly Vector3D Position;
+//             public readonly Vector3D Normal;
+//             public readonly Vector3D Tangent;
+//             public readonly Vector3D TexCoord;
+//             public readonly Vector3D TexCoord2;
+//             public readonly Color4D Color;
+//             public readonly List<(Assimp.Bone Bone, float Weight)> Weights;
+
+//             public Vertex( Vector3D position, Vector3D normal, Vector3D tangent, Vector3D texCoord, Vector3D texCoord2, Color4D color, List<(Assimp.Bone, float)> weights )
+//             {
+//                 Position = position;
+//                 Normal = normal;
+//                 Tangent = tangent;
+//                 TexCoord = texCoord;
+//                 TexCoord2 = texCoord2;
+//                 Color = color;
+//                 Weights = weights;
+//             }
+//         }
+//     }
+// }
diff --git a/GFDLibrary/Textures/TextureDecoder.cs b/GFDLibrary/Textures/TextureDecoder.cs
index e8e2792..86894d3 100644
--- a/GFDLibrary/Textures/TextureDecoder.cs
+++ b/GFDLibrary/Textures/TextureDecoder.cs
@@ -189,14 +189,14 @@ namespace GFDLibrary.Textures
                 case TextureFormat.DDS:
                 case TextureFormat.EPT:
                     return DecodeDDS( data );
-                case TextureFormat.TMX:
-                    return DecodeTMX( data );
-                case TextureFormat.TGA:
-                    return DecodeTGA( data );
-                case TextureFormat.GXT:
-                    return DecodeGXT( data );
-                case TextureFormat.GNF:
-                    return DecodeGNF(data);
+                //case TextureFormat.TMX:
+                //    return DecodeTMX( data );
+                //case TextureFormat.TGA:
+                //    return DecodeTGA( data );
+                //case TextureFormat.GXT:
+                //    return DecodeGXT( data );
+                //case TextureFormat.GNF:
+                //    return DecodeGNF(data);
                 default:
                     throw new NotSupportedException();
             }
@@ -291,27 +291,27 @@ namespace GFDLibrary.Textures
             return new Bitmap( bitmapStream );
         }
 
-        private static Bitmap DecodeTMX( byte[] data )
-        {
-            var tmx = new Scarlet.IO.ImageFormats.TMX();
-            tmx.Open( new MemoryStream( data ), Scarlet.IO.Endian.LittleEndian );
-            return tmx.GetBitmap();
-        }
-        private static Bitmap DecodeTGA( byte[] data )
-        {
-            return TgaDecoderTest.TgaDecoder.FromBinary( data );
-        }
-        private static Bitmap DecodeGXT( byte[] data )
-        {
-            var gxt = new Scarlet.IO.ImageFormats.GXT();
-            gxt.Open( new MemoryStream( data ), Scarlet.IO.Endian.LittleEndian );
-            return gxt.GetBitmap();
-        }
-        private static Bitmap DecodeGNF(byte[] data)
-        {
-            var gnf = new Scarlet.IO.ImageFormats.GNF();
-            gnf.Open(new MemoryStream(data), Scarlet.IO.Endian.LittleEndian);
-            return gnf.GetBitmap();
-        }
+        // private static Bitmap DecodeTMX( byte[] data )
+        // {
+        //     var tmx = new Scarlet.IO.ImageFormats.TMX();
+        //     tmx.Open( new MemoryStream( data ), Scarlet.IO.Endian.LittleEndian );
+        //     return tmx.GetBitmap();
+        // }
+        // private static Bitmap DecodeTGA( byte[] data )
+        // {
+        //     return TgaDecoderTest.TgaDecoder.FromBinary( data );
+        // }
+        // private static Bitmap DecodeGXT( byte[] data )
+        // {
+        //     var gxt = new Scarlet.IO.ImageFormats.GXT();
+        //     gxt.Open( new MemoryStream( data ), Scarlet.IO.Endian.LittleEndian );
+        //     return gxt.GetBitmap();
+        // }
+        // private static Bitmap DecodeGNF(byte[] data)
+        // {
+        //     var gnf = new Scarlet.IO.ImageFormats.GNF();
+        //     gnf.Open(new MemoryStream(data), Scarlet.IO.Endian.LittleEndian);
+        //     return gnf.GetBitmap();
+        // }
     }
 }
